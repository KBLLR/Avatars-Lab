<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>MonKnight Poster Generator v2.0</title>
  
  <!-- Extended Font Library -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Abril+Fatface&family=Archivo+Black&family=Bangers&family=Bebas+Neue&family=Big+Shoulders+Display:wght@400;700;900&family=Bodoni+Moda:ital,wght@0,400;0,700;1,400&family=Climate+Crisis&family=Comic+Neue:wght@400;700&family=Cormorant+Garamond:ital,wght@0,300;0,400;1,400&family=Courier+Prime&family=DM+Sans:wght@400;700;900&family=DM+Serif+Display:ital@0;1&family=Darker+Grotesque:wght@300;500;900&family=Epilogue:wght@100;400;900&family=Fraunces:ital,wght@0,400;0,900;1,400&family=IBM+Plex+Mono:wght@400;700&family=Inter:wght@100;400;700;900&family=JetBrains+Mono:wght@400;800&family=Josefin+Sans:wght@300;400;700&family=Libre+Barcode+39+Text&family=Major+Mono+Display&family=Manrope:wght@200;400;800&family=Noto+Sans+JP:wght@400;900&family=Orbitron:wght@400;900&family=Oswald:wght@300;700&family=Permanent+Marker&family=Playfair+Display:ital,wght@0,400;0,900;1,400;1,900&family=Poiret+One&family=Righteous&family=Rubik+Glitch&family=Rubik+Mono+One&family=Space+Grotesk:wght@300;700&family=Special+Elite&family=Syne:wght@400;800&family=Unbounded:wght@300;700;900&family=VT323&family=Work+Sans:wght@100;400;900&display=swap" rel="stylesheet">

  <style>
    /* ===== CSS VARIABLES & THEME ===== */
    :root {
      --bg: #09090b;
      --fg: #fafafa;
      --ui: #18181b;
      --ui-hover: #27272a;
      --bd: #3f3f46;
      --accent: #a78bfa;
      --accent-dim: #7c3aed;
      --success: #34d399;
      --warning: #fbbf24;
      --danger: #f87171;
      --glass: rgba(9,9,11,0.92);
      --radius: 10px;
      --shadow: 0 25px 50px -12px rgba(0,0,0,0.5);
    }

    * { box-sizing: border-box; }
    
    html, body {
      height: 100%;
      margin: 0;
      background: var(--bg);
      color: var(--fg);
      font: 11px/1.5 'Manrope', system-ui, sans-serif;
      overflow: hidden;
      -webkit-font-smoothing: antialiased;
    }

    body {
      display: flex;
      align-items: center;
      justify-content: center;
      background: 
        radial-gradient(ellipse at 20% 80%, rgba(167,139,250,0.08) 0%, transparent 50%),
        radial-gradient(ellipse at 80% 20%, rgba(52,211,153,0.05) 0%, transparent 50%),
        var(--bg);
    }

    /* ===== LAYOUT ===== */
    #app {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 100%;
      height: 100%;
      gap: 20px;
      padding: 20px;
    }

    /* ===== POSTER CONTAINER ===== */
    #poster-container {
      position: relative;
      height: 88vh;
      aspect-ratio: 2/3;
      background: #000;
      box-shadow: var(--shadow), 0 0 0 1px rgba(255,255,255,0.05);
      border-radius: 4px;
      overflow: hidden;
      transition: all 0.5s cubic-bezier(0.16, 1, 0.3, 1);
    }
    #poster-container.landscape { aspect-ratio: 3/2; height: 65vh; }
    #poster-container.square { aspect-ratio: 1/1; height: 75vh; }
    #poster-container.wide { aspect-ratio: 16/9; height: 55vh; }
    #poster-container.ultrawide { aspect-ratio: 21/9; height: 45vh; }

    #geo {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      z-index: 1;
    }

    /* Background Layer */
    #bg-layer {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      z-index: 0;
      pointer-events: none;
    }

    /* Typography Overlay */
    #typo-layer {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      z-index: 10;
      pointer-events: none;
      padding: 5%;
      display: grid;
      container-type: inline-size;
      transition: all 0.3s ease;
    }

    /* ===== TYPOGRAPHY STYLES (15+) ===== */

    /* 1. SWISS / INTERNATIONAL */
    .style-swiss { 
      grid-template-rows: auto 1fr auto; 
      grid-template-columns: 1fr 1fr; 
      text-transform: uppercase;
      font-family: 'Epilogue', sans-serif;
    }
    .style-swiss .title { grid-column: 1/-1; font-weight: 900; font-size: clamp(28px, 9cqw, 140px); letter-spacing: -0.05em; line-height: 0.85; }
    .style-swiss .meta { grid-column: 1; font-weight: 400; font-size: clamp(9px, 1.4cqw, 14px); margin-top: 16px; opacity: 0.8; }
    .style-swiss .desc { grid-column: 2; font-size: clamp(9px, 1.3cqw, 13px); text-align: left; align-self: end; padding-bottom: 24px; max-width: 90%; opacity: 0.7; }
    .style-swiss .sig { grid-column: 1/-1; font-size: clamp(9px, 1.2cqw, 12px); border-top: 1px solid currentColor; padding-top: 12px; display: flex; justify-content: space-between; align-self: end; opacity: 0.6; }

    /* 2. BRUTALIST */
    .style-brutal { 
      font-family: 'Archivo Black', sans-serif; 
      display: block;
    }
    .style-brutal .title { 
      position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%) rotate(-3deg);
      font-weight: 400; font-size: clamp(36px, 14cqw, 200px); 
      color: transparent; -webkit-text-stroke: 2px #fff; 
      text-align: center; line-height: 0.8;
      mix-blend-mode: difference;
    }
    .style-brutal .meta { 
      position: absolute; top: 5%; left: 5%; 
      background: #fff; color: #000; padding: 6px 14px; 
      font-family: 'IBM Plex Mono', monospace; font-size: 11px; font-weight: 700; 
      transform: rotate(-8deg); 
    }
    .style-brutal .desc { 
      position: absolute; bottom: 5%; left: 5%; 
      max-width: 180px; font-size: 10px; 
      background: rgba(0,0,0,0.9); padding: 12px; 
      font-family: 'IBM Plex Mono', monospace;
      border: 1px solid #fff;
    }
    .style-brutal .sig { 
      position: absolute; top: 5%; right: 5%; 
      border: 2px solid #fff; padding: 8px 16px; 
      font-family: 'IBM Plex Mono', monospace; font-size: 12px; font-weight: 700; 
    }

    /* 3. TECH / HUD */
    .style-tech { 
      font-family: 'JetBrains Mono', monospace; 
      grid-template-columns: 1fr auto 1fr; 
      grid-template-rows: auto 1fr auto; 
      letter-spacing: 0.08em; 
    }
    .style-tech .title { 
      grid-column: 1/-1; font-weight: 400; font-size: clamp(14px, 2.8cqw, 32px); 
      border-bottom: 1px solid rgba(255,255,255,0.3); padding-bottom: 12px; margin-bottom: 20px; 
      display: flex; justify-content: space-between; text-transform: uppercase;
    }
    .style-tech .meta { grid-column: 3; text-align: right; font-size: 9px; color: rgba(255,255,255,0.5); }
    .style-tech .desc { grid-column: 1; align-self: end; font-size: 8px; color: rgba(255,255,255,0.5); max-width: 140px; border-left: 1px solid rgba(255,255,255,0.3); padding-left: 10px; }
    .style-tech .sig { grid-column: 1/-1; text-align: center; font-size: 9px; opacity: 0.4; margin-top: 20px; }
    .style-tech::before { content:''; position:absolute; top:20px; left:20px; width:12px; height:12px; border-top:1px solid rgba(255,255,255,0.5); border-left:1px solid rgba(255,255,255,0.5); }
    .style-tech::after { content:''; position:absolute; bottom:20px; right:20px; width:12px; height:12px; border-bottom:1px solid rgba(255,255,255,0.5); border-right:1px solid rgba(255,255,255,0.5); }

    /* 4. GALLERY / ART */
    .style-art { 
      font-family: 'DM Serif Display', serif; 
      grid-template-rows: 1fr auto auto; 
      text-align: center; 
    }
    .style-art .title { font-weight: 400; font-size: clamp(22px, 5.5cqw, 72px); align-self: end; margin-bottom: 24px; font-style: italic; }
    .style-art .meta { font-family: 'Manrope', sans-serif; font-size: 8px; text-transform: uppercase; letter-spacing: 0.25em; margin-bottom: 40px; opacity: 0.6; }
    .style-art .desc { display: none; }
    .style-art .sig { font-family: 'Manrope', sans-serif; font-size: 8px; opacity: 0.4; letter-spacing: 0.1em; }

    /* 5. BAUHAUS */
    .style-bauhaus { 
      font-family: 'Work Sans', sans-serif; 
      display: block;
    }
    .style-bauhaus .title { 
      position: absolute; top: 10%; left: -15%; 
      font-weight: 900; font-size: clamp(36px, 12cqw, 180px); 
      transform: rotate(-45deg); 
      mix-blend-mode: overlay; 
      white-space: nowrap; 
      color: rgba(255,255,255,0.7);
      text-transform: uppercase;
    }
    .style-bauhaus .meta { 
      position: absolute; bottom: 8%; left: 8%; 
      font-weight: 800; font-size: 13px; 
      writing-mode: vertical-rl; transform: rotate(180deg); 
      text-transform: uppercase; letter-spacing: 0.1em;
    }
    .style-bauhaus .desc { 
      position: absolute; bottom: 8%; right: 8%; 
      width: 130px; font-size: 9px; text-align: right; 
      opacity: 0.7;
    }
    .style-bauhaus .sig { 
      position: absolute; top: 8%; right: 8%; 
      font-weight: 700; border-bottom: 4px solid #fff; 
      padding-bottom: 4px; font-size: 11px;
      text-transform: uppercase;
    }

    /* 6. EDITORIAL */
    .style-editorial { 
      font-family: 'Bodoni Moda', serif; 
      text-align: center; 
      display: block;
    }
    .style-editorial .title { 
      position: absolute; top: 8%; left: 0; width: 100%; 
      font-weight: 900; font-size: clamp(42px, 15cqw, 180px); 
      line-height: 0.75; letter-spacing: -0.04em; 
      text-transform: uppercase;
    }
    .style-editorial .meta { 
      position: absolute; bottom: 8%; left: 50%; transform: translateX(-50%); 
      font-family: 'Manrope', sans-serif; text-transform: uppercase; 
      letter-spacing: 0.2em; font-size: 9px; opacity: 0.6;
    }
    .style-editorial .desc { display: none; }
    .style-editorial .sig { 
      position: absolute; top: 3%; right: 5%; 
      font-family: 'Manrope', sans-serif; font-size: 8px; opacity: 0.4; 
    }

    /* 7. ACID GRAPHIX */
    .style-acid { 
      font-family: 'Unbounded', sans-serif; 
      display: flex; align-items: center; justify-content: center; 
    }
    .style-acid .title {
      font-weight: 700; font-size: clamp(26px, 9cqw, 120px); text-align: center;
      background: linear-gradient(135deg, #ff006e, #8338ec, #3a86ff);
      -webkit-background-clip: text; -webkit-text-fill-color: transparent;
      background-clip: text;
      filter: drop-shadow(0 0 20px rgba(131,56,236,0.5));
      text-transform: uppercase;
    }
    .style-acid .meta { 
      position: absolute; top: 50%; left: 0; width: 100%; text-align: center; 
      font-family: 'VT323', monospace; font-size: 16px; letter-spacing: 8px; 
      mix-blend-mode: exclusion; transform: translateY(60px);
      text-transform: uppercase;
    }
    .style-acid .desc { 
      position: absolute; bottom: 8%; width: 100%; text-align: center; 
      font-size: 8px; text-transform: uppercase; letter-spacing: 0.15em; opacity: 0.5;
    }
    .style-acid .sig { position: absolute; bottom: 5%; right: 5%; font-family: 'VT323', monospace; font-size: 14px; }

    /* 8. ZEN / VERTICAL */
    .style-zen { 
      font-family: 'Darker Grotesque', sans-serif; 
      writing-mode: vertical-rl; 
      align-items: flex-start; 
      padding-top: 12%; 
    }
    .style-zen .title { font-weight: 300; font-size: clamp(22px, 5.5cqw, 64px); letter-spacing: 0.15em; margin-left: 24px; }
    .style-zen .meta { font-size: 10px; color: rgba(255,255,255,0.6); margin-left: 12px; letter-spacing: 0.1em; }
    .style-zen .desc { font-size: 9px; color: rgba(255,255,255,0.4); max-height: 200px; margin-left: 36px; }
    .style-zen .sig { 
      position: absolute; bottom: 8%; left: 8%; 
      writing-mode: horizontal-tb; 
      border: 1px solid rgba(255,255,255,0.5); border-radius: 50%; 
      width: 44px; height: 44px; 
      display: flex; align-items: center; justify-content: center; 
      font-size: 7px; letter-spacing: 0;
    }

    /* 9. RETRO FRAME */
    .style-retro { 
      font-family: 'Fraunces', serif; 
      display: flex; flex-direction: column; 
      justify-content: center; align-items: center; 
      border: 2px solid rgba(255,255,255,0.8); 
      margin: 6%; padding: 5%; 
      width: calc(100% - 12%); height: calc(100% - 12%); 
    }
    .style-retro .title { font-weight: 400; font-size: clamp(22px, 6cqw, 80px); border-bottom: 1px solid rgba(255,255,255,0.5); padding-bottom: 12px; margin-bottom: 12px; text-align: center; }
    .style-retro .meta { font-family: 'IBM Plex Mono', monospace; font-size: 9px; text-transform: uppercase; letter-spacing: 0.15em; margin-bottom: 24px; opacity: 0.6; }
    .style-retro .desc { font-family: 'Manrope', sans-serif; text-align: center; font-size: 10px; max-width: 280px; line-height: 1.7; opacity: 0.7; }
    .style-retro .sig { margin-top: auto; font-family: 'IBM Plex Mono', monospace; font-size: 8px; opacity: 0.5; }

    /* 10. VAPORWAVE */
    .style-vaporwave { 
      font-family: 'Major Mono Display', monospace; 
      display: flex; flex-direction: column; 
      align-items: center; justify-content: center; 
      text-align: center;
    }
    .style-vaporwave .title { 
      font-size: clamp(24px, 8cqw, 100px); 
      background: linear-gradient(180deg, #ff71ce 0%, #01cdfe 50%, #05ffa1 100%);
      -webkit-background-clip: text; -webkit-text-fill-color: transparent;
      background-clip: text;
      text-shadow: 4px 4px 0 rgba(255,113,206,0.3);
      letter-spacing: 0.05em;
    }
    .style-vaporwave .meta { 
      font-family: 'VT323', monospace; font-size: 18px; 
      color: #01cdfe; margin-top: 20px; letter-spacing: 0.3em;
    }
    .style-vaporwave .desc { 
      font-family: 'VT323', monospace; font-size: 14px; 
      color: #ff71ce; margin-top: 30px; max-width: 300px;
    }
    .style-vaporwave .sig { 
      position: absolute; bottom: 5%; right: 5%; 
      font-family: 'VT323', monospace; color: #05ffa1; font-size: 14px;
    }

    /* 11. CYBERPUNK */
    .style-cyberpunk { 
      font-family: 'Bebas Neue', sans-serif; 
      display: block;
    }
    .style-cyberpunk .title { 
      position: absolute; bottom: 15%; left: 5%; 
      font-size: clamp(36px, 14cqw, 200px); 
      line-height: 0.8; letter-spacing: 0.02em;
      color: #fcee0a;
      text-shadow: 3px 3px 0 #00f0ff, -1px -1px 0 #ff0055;
      text-transform: uppercase;
    }
    .style-cyberpunk .meta { 
      position: absolute; top: 5%; right: 5%; 
      font-family: 'JetBrains Mono', monospace; font-size: 10px; 
      color: #00f0ff; text-transform: uppercase; letter-spacing: 0.1em;
      border: 1px solid #00f0ff; padding: 6px 12px;
    }
    .style-cyberpunk .desc { 
      position: absolute; top: 5%; left: 5%; 
      font-family: 'JetBrains Mono', monospace; font-size: 9px; 
      color: #ff0055; max-width: 200px;
    }
    .style-cyberpunk .sig { 
      position: absolute; bottom: 5%; right: 5%; 
      font-family: 'JetBrains Mono', monospace; font-size: 12px; 
      color: #00f0ff;
    }

    /* 12. MEMPHIS */
    .style-memphis { 
      font-family: 'Syne', sans-serif; 
      display: block;
      background: 
        radial-gradient(circle at 20% 80%, #ff6b6b 0, #ff6b6b 40px, transparent 40px),
        radial-gradient(circle at 80% 20%, #4ecdc4 0, #4ecdc4 60px, transparent 60px),
        radial-gradient(circle at 60% 60%, #ffe66d 0, #ffe66d 30px, transparent 30px);
    }
    .style-memphis .title { 
      position: absolute; top: 50%; left: 50%; 
      transform: translate(-50%, -50%) rotate(-5deg);
      font-weight: 800; font-size: clamp(32px, 10cqw, 140px); 
      color: #1a1a2e; 
      background: #fff; padding: 10px 30px;
      text-transform: uppercase;
    }
    .style-memphis .meta { 
      position: absolute; top: 8%; left: 8%; 
      font-weight: 400; font-size: 12px; 
      color: #fff; background: #ff6b6b; padding: 8px 16px;
      transform: rotate(3deg);
    }
    .style-memphis .desc { 
      position: absolute; bottom: 8%; right: 8%; 
      font-size: 10px; color: #fff; max-width: 180px; 
      background: #1a1a2e; padding: 12px; 
    }
    .style-memphis .sig { 
      position: absolute; bottom: 8%; left: 8%; 
      font-size: 14px; color: #1a1a2e; font-weight: 800;
    }

    /* 13. ART DECO */
    .style-deco { 
      font-family: 'Abril Fatface', serif; 
      display: flex; flex-direction: column; 
      align-items: center; justify-content: center; text-align: center;
      border: 3px double rgba(212,175,55,0.8); 
      margin: 5%; padding: 4%;
      width: calc(100% - 10%); height: calc(100% - 10%);
    }
    .style-deco .title { 
      font-size: clamp(28px, 8cqw, 110px); 
      color: #d4af37; letter-spacing: 0.08em;
      text-transform: uppercase;
    }
    .style-deco .meta { 
      font-family: 'Manrope', sans-serif; font-size: 10px; 
      letter-spacing: 0.4em; color: rgba(212,175,55,0.7); 
      margin-top: 20px; text-transform: uppercase;
    }
    .style-deco .desc { display: none; }
    .style-deco .sig { 
      margin-top: auto; 
      font-family: 'Manrope', sans-serif; font-size: 9px; 
      color: rgba(212,175,55,0.5); letter-spacing: 0.2em;
    }
    .style-deco::before {
      content: '◆';
      position: absolute; top: 15%; left: 50%; transform: translateX(-50%);
      font-size: 20px; color: #d4af37;
    }

    /* 14. GRUNGE */
    .style-grunge { 
      font-family: 'Archivo Black', sans-serif; 
      display: block;
    }
    .style-grunge .title { 
      position: absolute; top: 20%; left: 5%; 
      font-size: clamp(30px, 12cqw, 160px); 
      line-height: 0.85; text-transform: uppercase;
      color: #fff;
      text-shadow: 
        2px 2px 0 #000, -2px -2px 0 #000, 
        2px -2px 0 #000, -2px 2px 0 #000;
      transform: skewY(-3deg);
    }
    .style-grunge .meta { 
      position: absolute; bottom: 25%; right: 5%; 
      font-family: 'VT323', monospace; font-size: 16px; 
      color: #ff0000; text-transform: uppercase;
      transform: rotate(5deg);
    }
    .style-grunge .desc { 
      position: absolute; bottom: 8%; left: 5%; 
      font-family: 'IBM Plex Mono', monospace; font-size: 9px; 
      max-width: 250px; opacity: 0.6;
      border-left: 3px solid #fff; padding-left: 10px;
    }
    .style-grunge .sig { 
      position: absolute; bottom: 8%; right: 5%; 
      font-family: 'VT323', monospace; font-size: 20px;
    }

    /* 15. MINIMALIST */
    .style-minimal { 
      font-family: 'Darker Grotesque', sans-serif; 
      display: flex; flex-direction: column; 
      justify-content: flex-end; 
    }
    .style-minimal .title { 
      font-weight: 900; font-size: clamp(28px, 8cqw, 120px); 
      line-height: 0.9; margin-bottom: 20px;
    }
    .style-minimal .meta { 
      font-weight: 300; font-size: clamp(10px, 1.5cqw, 14px); 
      opacity: 0.5; margin-bottom: 8px;
    }
    .style-minimal .desc { display: none; }
    .style-minimal .sig { 
      font-weight: 300; font-size: 9px; opacity: 0.3;
    }

    /* 16. CONSTRUCTIVIST */
    .style-construct { 
      font-family: 'Oswald', sans-serif; 
      display: block;
      text-transform: uppercase;
    }
    .style-construct .title { 
      position: absolute; top: 10%; left: 10%; 
      font-weight: 700; font-size: clamp(32px, 10cqw, 140px); 
      color: #e63946; line-height: 0.85;
      transform: rotate(-10deg);
    }
    .style-construct .meta { 
      position: absolute; bottom: 30%; right: 10%; 
      font-weight: 300; font-size: 14px; 
      background: #000; color: #fff; padding: 8px 20px;
      transform: rotate(5deg);
    }
    .style-construct .desc { 
      position: absolute; bottom: 10%; left: 10%; 
      font-weight: 300; font-size: 10px; max-width: 200px;
      color: rgba(255,255,255,0.7);
    }
    .style-construct .sig { 
      position: absolute; top: 10%; right: 10%; 
      font-weight: 700; font-size: 12px;
    }
    .style-construct::before {
      content: '';
      position: absolute; top: 0; left: 30%;
      width: 3px; height: 100%; background: #e63946;
      transform: rotate(15deg);
    }

    /* 17. GLITCH */
    .style-glitch { 
      font-family: 'Rubik Glitch', cursive; 
      display: flex; align-items: center; justify-content: center;
    }
    .style-glitch .title { 
      font-size: clamp(32px, 10cqw, 140px); 
      color: #fff;
      text-shadow: 
        2px 0 #ff0000, -2px 0 #00ffff,
        0 0 10px rgba(255,255,255,0.5);
      animation: glitchAnim 2s infinite;
    }
    @keyframes glitchAnim {
      0%, 90%, 100% { transform: translate(0); }
      92% { transform: translate(-2px, 1px); }
      94% { transform: translate(2px, -1px); }
      96% { transform: translate(-1px, 2px); }
      98% { transform: translate(1px, -2px); }
    }
    .style-glitch .meta { 
      position: absolute; bottom: 20%; left: 50%; transform: translateX(-50%);
      font-family: 'JetBrains Mono', monospace; font-size: 12px; 
      letter-spacing: 0.2em; color: #00ffff;
    }
    .style-glitch .desc { display: none; }
    .style-glitch .sig { 
      position: absolute; bottom: 5%; right: 5%; 
      font-family: 'JetBrains Mono', monospace; font-size: 10px; color: #ff0000;
    }

    /* 18. DE STIJL / NEOPLASTICISM */
    .style-destijl {
      font-family: 'Work Sans', sans-serif;
      display: block;
      text-transform: uppercase;
    }
    .style-destijl::before {
      content: '';
      position: absolute; top: 10%; left: 10%;
      width: 30%; height: 25%;
      background: #d40000;
    }
    .style-destijl::after {
      content: '';
      position: absolute; bottom: 15%; right: 8%;
      width: 20%; height: 20%;
      background: #003082;
    }
    .style-destijl .title {
      position: absolute; top: 38%; left: 10%;
      font-weight: 900; font-size: clamp(24px, 8cqw, 100px);
      color: #000; background: #f0e100;
      padding: 8px 24px; line-height: 1;
    }
    .style-destijl .meta {
      position: absolute; bottom: 10%; left: 10%;
      font-weight: 700; font-size: 11px;
      letter-spacing: 0.15em; color: #000;
    }
    .style-destijl .desc { display: none; }
    .style-destijl .sig {
      position: absolute; top: 10%; right: 10%;
      font-weight: 700; font-size: 10px; color: #fff;
    }

    /* 19. PSYCHEDELIC 60s */
    .style-psychedelic {
      font-family: 'Righteous', cursive;
      display: flex; align-items: center; justify-content: center;
      text-align: center;
    }
    .style-psychedelic .title {
      font-size: clamp(28px, 10cqw, 130px);
      background: linear-gradient(45deg, #ff6b6b, #feca57, #48dbfb, #ff9ff3, #54a0ff, #5f27cd);
      background-size: 300% 300%;
      -webkit-background-clip: text; -webkit-text-fill-color: transparent;
      background-clip: text;
      animation: psycheGradient 5s ease infinite;
      text-transform: uppercase;
      letter-spacing: -0.02em;
    }
    @keyframes psycheGradient {
      0%, 100% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
    }
    .style-psychedelic .meta {
      position: absolute; bottom: 25%;
      font-family: 'Permanent Marker', cursive;
      font-size: 16px; color: #feca57;
      transform: rotate(-5deg);
    }
    .style-psychedelic .desc { display: none; }
    .style-psychedelic .sig {
      position: absolute; bottom: 8%; right: 8%;
      font-family: 'Permanent Marker', cursive;
      font-size: 14px; color: #ff6b6b;
    }

    /* 20. ART NOUVEAU */
    .style-nouveau {
      font-family: 'Cormorant Garamond', serif;
      display: flex; flex-direction: column;
      align-items: center; justify-content: center;
      text-align: center;
    }
    .style-nouveau .title {
      font-weight: 300; font-size: clamp(26px, 7cqw, 90px);
      font-style: italic; letter-spacing: 0.1em;
      color: #c9a959;
      text-shadow: 0 2px 10px rgba(201,169,89,0.3);
    }
    .style-nouveau .meta {
      font-size: 11px; letter-spacing: 0.3em;
      margin-top: 20px; color: rgba(201,169,89,0.7);
      text-transform: uppercase;
    }
    .style-nouveau .desc {
      font-size: 12px; font-style: italic;
      max-width: 300px; margin-top: 30px;
      color: rgba(255,255,255,0.6);
      line-height: 1.8;
    }
    .style-nouveau .sig {
      margin-top: auto; font-size: 10px;
      color: rgba(201,169,89,0.5);
      letter-spacing: 0.2em;
    }
    .style-nouveau::before {
      content: '❧';
      position: absolute; top: 12%;
      font-size: 30px; color: #c9a959;
    }
    .style-nouveau::after {
      content: '❧';
      position: absolute; bottom: 12%;
      font-size: 30px; color: #c9a959;
      transform: rotate(180deg);
    }

    /* 21. POP ART */
    .style-popart {
      font-family: 'Bangers', cursive;
      display: block;
    }
    .style-popart .title {
      position: absolute; top: 50%; left: 50%;
      transform: translate(-50%, -50%) rotate(-8deg);
      font-size: clamp(36px, 12cqw, 160px);
      color: #fff;
      text-shadow: 
        4px 4px 0 #000,
        8px 8px 0 #ff0066,
        12px 12px 0 #00ccff;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }
    .style-popart .meta {
      position: absolute; top: 8%; left: 8%;
      font-family: 'Comic Neue', cursive;
      font-size: 14px; font-weight: 700;
      background: #ff0066; color: #fff;
      padding: 8px 16px; transform: rotate(5deg);
      border: 3px solid #000;
    }
    .style-popart .desc { display: none; }
    .style-popart .sig {
      position: absolute; bottom: 8%; right: 8%;
      font-family: 'Comic Neue', cursive;
      font-size: 16px; font-weight: 700;
      background: #00ccff; color: #000;
      padding: 6px 14px; border: 3px solid #000;
    }

    /* 22. FUTURISM */
    .style-futurism {
      font-family: 'Bebas Neue', sans-serif;
      display: block;
      text-transform: uppercase;
    }
    .style-futurism .title {
      position: absolute; top: 15%; left: 5%;
      font-size: clamp(28px, 11cqw, 150px);
      line-height: 0.8; letter-spacing: 0.05em;
      color: #fff;
      transform: perspective(300px) rotateY(-15deg);
      transform-origin: left center;
    }
    .style-futurism .meta {
      position: absolute; bottom: 35%; right: 10%;
      font-family: 'Oswald', sans-serif;
      font-size: 14px; font-weight: 300;
      letter-spacing: 0.3em;
      transform: rotate(-90deg);
      transform-origin: right center;
    }
    .style-futurism .desc {
      position: absolute; bottom: 10%; left: 5%;
      font-family: 'Oswald', sans-serif;
      font-size: 10px; font-weight: 300;
      max-width: 200px; letter-spacing: 0.1em;
      opacity: 0.6;
    }
    .style-futurism .sig {
      position: absolute; bottom: 10%; right: 10%;
      font-family: 'Oswald', sans-serif;
      font-size: 11px; letter-spacing: 0.2em;
    }

    /* 23. NEUE GRAFIK / MÜLLER-BROCKMANN */
    .style-neuegrafik {
      font-family: 'Helvetica Neue', 'Helvetica', 'Arial', sans-serif;
      display: grid;
      grid-template-columns: 1fr 1fr;
      grid-template-rows: auto 1fr auto;
      text-transform: lowercase;
    }
    .style-neuegrafik .title {
      grid-column: 1/-1;
      font-weight: 700; font-size: clamp(32px, 10cqw, 140px);
      line-height: 0.95; letter-spacing: -0.03em;
      padding-bottom: 20px;
      border-bottom: 4px solid currentColor;
    }
    .style-neuegrafik .meta {
      grid-column: 1;
      font-weight: 400; font-size: 12px;
      margin-top: 20px; opacity: 0.6;
    }
    .style-neuegrafik .desc {
      grid-column: 2;
      font-size: 11px; text-align: right;
      align-self: start; margin-top: 20px;
      max-width: 200px; margin-left: auto;
      opacity: 0.5; line-height: 1.6;
    }
    .style-neuegrafik .sig {
      grid-column: 1/-1;
      font-size: 10px; opacity: 0.4;
      border-top: 1px solid currentColor;
      padding-top: 12px; align-self: end;
    }

    /* 24. PUNK / DIY */
    .style-punk {
      font-family: 'Special Elite', cursive;
      display: block;
    }
    .style-punk .title {
      position: absolute; top: 20%; left: 5%;
      font-size: clamp(24px, 9cqw, 110px);
      color: #fff; background: #000;
      padding: 5px 15px;
      transform: rotate(-3deg);
      border: 2px solid #fff;
      text-transform: uppercase;
    }
    .style-punk .meta {
      position: absolute; top: 55%; right: 10%;
      font-size: 14px;
      background: #ff0000; color: #fff;
      padding: 4px 12px;
      transform: rotate(8deg);
    }
    .style-punk .desc {
      position: absolute; bottom: 15%; left: 8%;
      font-size: 11px; max-width: 180px;
      background: #fff; color: #000;
      padding: 8px; transform: rotate(-2deg);
    }
    .style-punk .sig {
      position: absolute; bottom: 5%; right: 5%;
      font-size: 12px;
      text-decoration: line-through;
    }

    /* 25. POSTMODERN */
    .style-postmodern {
      font-family: 'Space Grotesk', sans-serif;
      display: block;
    }
    .style-postmodern .title {
      position: absolute; top: 25%; left: 8%;
      font-weight: 700; font-size: clamp(28px, 9cqw, 120px);
      line-height: 0.9;
      background: linear-gradient(90deg, #ff6b6b 0%, #4ecdc4 50%, #ffe66d 100%);
      -webkit-background-clip: text; -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    .style-postmodern .meta {
      position: absolute; top: 8%; right: 8%;
      font-weight: 300; font-size: 10px;
      letter-spacing: 0.2em;
      border: 1px solid #4ecdc4;
      padding: 8px 16px;
    }
    .style-postmodern .desc {
      position: absolute; bottom: 20%; right: 8%;
      font-size: 10px; max-width: 180px;
      text-align: right; opacity: 0.7;
      border-right: 2px solid #ffe66d;
      padding-right: 12px;
    }
    .style-postmodern .sig {
      position: absolute; bottom: 8%; left: 8%;
      font-size: 11px; font-weight: 700;
      color: #ff6b6b;
    }

    /* 26. STREAMLINE MODERNE */
    .style-streamline {
      font-family: 'Poiret One', cursive;
      display: flex; flex-direction: column;
      align-items: center; justify-content: center;
      text-align: center;
    }
    .style-streamline .title {
      font-size: clamp(30px, 9cqw, 120px);
      letter-spacing: 0.15em;
      text-transform: uppercase;
    }
    .style-streamline .meta {
      font-family: 'Josefin Sans', sans-serif;
      font-size: 11px; letter-spacing: 0.4em;
      margin-top: 24px; opacity: 0.6;
    }
    .style-streamline .desc { display: none; }
    .style-streamline .sig {
      font-family: 'Josefin Sans', sans-serif;
      font-size: 9px; letter-spacing: 0.3em;
      margin-top: auto; opacity: 0.4;
    }
    .style-streamline::before {
      content: '';
      position: absolute; top: 50%; left: 10%;
      width: 80%; height: 1px;
      background: linear-gradient(90deg, transparent, currentColor, transparent);
      transform: translateY(-60px);
    }
    .style-streamline::after {
      content: '';
      position: absolute; top: 50%; left: 10%;
      width: 80%; height: 1px;
      background: linear-gradient(90deg, transparent, currentColor, transparent);
      transform: translateY(60px);
    }

    /* 27. DADAISM */
    .style-dada {
      font-family: 'Courier Prime', monospace;
      display: block;
    }
    .style-dada .title {
      position: absolute; top: 30%; left: 15%;
      font-size: clamp(20px, 7cqw, 80px);
      transform: rotate(-12deg);
      mix-blend-mode: difference;
    }
    .style-dada .meta {
      position: absolute; top: 10%; right: 20%;
      font-family: 'Special Elite', cursive;
      font-size: 18px;
      transform: rotate(45deg) scale(1.5);
      opacity: 0.6;
    }
    .style-dada .desc {
      position: absolute; bottom: 25%; left: 50%;
      font-size: 9px;
      transform: rotate(90deg);
      transform-origin: left center;
      max-width: 150px;
    }
    .style-dada .sig {
      position: absolute; bottom: 10%; left: 10%;
      font-size: 24px;
      transform: scaleX(-1);
    }

    /* 28. JAPANESE MODERNISM */
    .style-jpmod {
      font-family: 'Noto Sans JP', sans-serif;
      display: grid;
      grid-template-columns: 1fr auto;
      grid-template-rows: 1fr auto;
    }
    .style-jpmod .title {
      grid-column: 1;
      font-weight: 900; font-size: clamp(36px, 12cqw, 160px);
      writing-mode: vertical-rl;
      line-height: 0.9;
      align-self: start;
    }
    .style-jpmod .meta {
      grid-column: 2;
      writing-mode: vertical-rl;
      font-size: 10px; letter-spacing: 0.3em;
      opacity: 0.5;
      align-self: end;
    }
    .style-jpmod .desc {
      grid-column: 1/-1;
      font-size: 9px;
      text-align: right;
      opacity: 0.4;
    }
    .style-jpmod .sig {
      position: absolute; bottom: 8%; left: 8%;
      width: 40px; height: 40px;
      border: 2px solid currentColor;
      border-radius: 50%;
      display: flex; align-items: center; justify-content: center;
      font-size: 8px;
    }

    /* 29. WERKBUND */
    .style-werkbund {
      font-family: 'DM Sans', sans-serif;
      display: grid;
      grid-template-rows: auto 1fr auto;
      text-transform: uppercase;
    }
    .style-werkbund .title {
      font-weight: 900; font-size: clamp(24px, 7cqw, 90px);
      letter-spacing: 0.1em;
      border-left: 6px solid currentColor;
      padding-left: 20px;
      line-height: 1.1;
    }
    .style-werkbund .meta {
      font-weight: 400; font-size: 10px;
      letter-spacing: 0.2em;
      margin-top: 30px; opacity: 0.6;
    }
    .style-werkbund .desc {
      font-size: 9px; max-width: 250px;
      line-height: 1.8; opacity: 0.5;
      margin-top: 20px;
    }
    .style-werkbund .sig {
      align-self: end;
      font-size: 9px; letter-spacing: 0.15em;
      opacity: 0.4;
    }

    /* 30. KINETIC / OP ART */
    .style-kinetic {
      font-family: 'Orbitron', sans-serif;
      display: flex; align-items: center; justify-content: center;
      overflow: hidden;
    }
    .style-kinetic .title {
      font-weight: 900; font-size: clamp(28px, 9cqw, 120px);
      text-transform: uppercase;
      letter-spacing: 0.1em;
      background: repeating-linear-gradient(
        90deg,
        #fff 0px, #fff 2px,
        transparent 2px, transparent 8px
      );
      -webkit-background-clip: text; -webkit-text-fill-color: transparent;
      background-clip: text;
      animation: kineticShift 3s linear infinite;
    }
    @keyframes kineticShift {
      0% { background-position: 0 0; }
      100% { background-position: 100px 0; }
    }
    .style-kinetic .meta {
      position: absolute; bottom: 25%;
      font-size: 11px; letter-spacing: 0.5em;
      opacity: 0.5;
    }
    .style-kinetic .desc { display: none; }
    .style-kinetic .sig {
      position: absolute; bottom: 8%; right: 8%;
      font-size: 10px; letter-spacing: 0.2em;
    }

    /* 31. RUSSIAN AVANT-GARDE */
    .style-avantgarde {
      font-family: 'Oswald', sans-serif;
      display: block;
      text-transform: uppercase;
    }
    .style-avantgarde .title {
      position: absolute; top: 20%; left: -5%;
      font-weight: 700; font-size: clamp(36px, 14cqw, 200px);
      color: #c41e3a;
      transform: rotate(-25deg);
      line-height: 0.8;
      white-space: nowrap;
    }
    .style-avantgarde .meta {
      position: absolute; top: 8%; right: 8%;
      font-weight: 300; font-size: 12px;
      letter-spacing: 0.15em;
      background: #000; color: #fff;
      padding: 8px 20px;
    }
    .style-avantgarde .desc {
      position: absolute; bottom: 10%; right: 8%;
      font-weight: 300; font-size: 10px;
      max-width: 180px; text-align: right;
      color: rgba(255,255,255,0.6);
    }
    .style-avantgarde .sig {
      position: absolute; bottom: 10%; left: 8%;
      font-weight: 700; font-size: 14px;
      color: #c41e3a;
    }

    /* 32. CONCRETE POETRY */
    .style-concrete {
      font-family: 'IBM Plex Mono', monospace;
      display: flex; align-items: center; justify-content: center;
    }
    .style-concrete .title {
      font-weight: 400; font-size: clamp(18px, 5cqw, 60px);
      text-align: center;
      word-spacing: 0.5em;
      line-height: 1.8;
      max-width: 80%;
    }
    .style-concrete .meta { display: none; }
    .style-concrete .desc { display: none; }
    .style-concrete .sig {
      position: absolute; bottom: 5%;
      font-size: 9px; opacity: 0.3;
    }

    /* ===== GRID OVERLAY SYSTEM ===== */
    #grid-overlay {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      z-index: 100;
      pointer-events: none;
      display: none;
    }
    #grid-overlay.active {
      display: block;
    }
    .grid-column {
      position: absolute;
      top: 0; height: 100%;
      background: rgba(0, 150, 255, 0.08);
      border-left: 1px solid rgba(0, 150, 255, 0.25);
      border-right: 1px solid rgba(0, 150, 255, 0.25);
    }
    .grid-row {
      position: absolute;
      left: 0; width: 100%;
      background: rgba(255, 100, 0, 0.06);
      border-top: 1px solid rgba(255, 100, 0, 0.2);
      border-bottom: 1px solid rgba(255, 100, 0, 0.2);
    }
    .grid-gutter {
      position: absolute;
      top: 0; height: 100%;
      background: rgba(255, 0, 100, 0.05);
    }
    .grid-margin {
      position: absolute;
      background: rgba(100, 100, 100, 0.08);
      border: 1px dashed rgba(100, 100, 100, 0.2);
    }

    /* ===== COMPOSITION GUIDES OVERLAY ===== */
    #comp-guides {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      z-index: 99;
      pointer-events: none;
      display: none;
    }
    #comp-guides.active {
      display: block;
    }
    .guide-line {
      position: absolute;
      background: rgba(255, 200, 0, 0.4);
    }
    .guide-line.horizontal {
      height: 1px; width: 100%;
    }
    .guide-line.vertical {
      width: 1px; height: 100%;
    }
    .guide-line.diagonal {
      height: 1px;
      transform-origin: left center;
    }
    .guide-point {
      position: absolute;
      width: 8px; height: 8px;
      border: 1px solid rgba(255, 200, 0, 0.6);
      border-radius: 50%;
      transform: translate(-50%, -50%);
    }

    /* ===== DRAGGABLE TEXT ELEMENTS ===== */
    #typo-layer.edit-mode {
      pointer-events: auto;
    }
    #typo-layer.edit-mode .title,
    #typo-layer.edit-mode .meta,
    #typo-layer.edit-mode .desc,
    #typo-layer.edit-mode .sig {
      cursor: move;
      outline: 1px dashed rgba(0, 150, 255, 0.4);
      outline-offset: 4px;
    }
    #typo-layer.edit-mode .title:hover,
    #typo-layer.edit-mode .meta:hover,
    #typo-layer.edit-mode .desc:hover,
    #typo-layer.edit-mode .sig:hover {
      outline-color: rgba(0, 150, 255, 0.8);
    }
    .element-selected {
      outline: 2px solid rgba(0, 200, 100, 0.9) !important;
    }
    .snap-indicator {
      position: absolute;
      background: rgba(0, 255, 100, 0.6);
      z-index: 200;
    }
    .snap-indicator.h { height: 1px; width: 100%; }
    .snap-indicator.v { width: 1px; height: 100%; }

    /* ===== UI PANELS ===== */
    .panel {
      position: fixed;
      background: linear-gradient(
        135deg,
        rgba(20, 20, 24, 0.85) 0%,
        rgba(12, 12, 14, 0.92) 100%
      );
      backdrop-filter: blur(24px) saturate(1.2);
      -webkit-backdrop-filter: blur(24px) saturate(1.2);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: var(--radius);
      padding: 14px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      box-shadow: 
        var(--shadow),
        inset 0 1px 0 rgba(255,255,255,0.05),
        0 0 0 1px rgba(0,0,0,0.3);
      z-index: 50;
      max-height: 92vh;
      overflow-y: auto;
      overflow-x: hidden;
      scrollbar-width: thin;
      scrollbar-color: var(--bd) transparent;
      transition: all 0.4s cubic-bezier(0.16, 1, 0.3, 1);
      transform-origin: top left;
    }
    .panel::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 1px;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent);
      pointer-events: none;
    }
    .panel::-webkit-scrollbar { width: 4px; }
    .panel::-webkit-scrollbar-thumb { background: var(--bd); border-radius: 2px; }

    #ui-left { top: 16px; left: 16px; width: 240px; transform-origin: top left; }
    #ui-right { top: 16px; right: 16px; width: 260px; transform-origin: top right; }

    /* ===== MINIMIZED PANEL STATE ===== */
    .panel.minimized {
      width: 48px !important;
      height: 48px !important;
      min-height: 48px;
      padding: 0;
      border-radius: 14px;
      overflow: hidden;
      cursor: pointer;
      background: linear-gradient(
        135deg,
        rgba(30, 30, 36, 0.95) 0%,
        rgba(18, 18, 22, 0.98) 100%
      );
      box-shadow: 
        0 8px 32px rgba(0,0,0,0.4),
        inset 0 1px 0 rgba(255,255,255,0.08),
        0 0 0 1px rgba(255,255,255,0.05);
    }
    .panel.minimized:hover {
      transform: scale(1.08);
      box-shadow: 
        0 12px 40px rgba(0,0,0,0.5),
        inset 0 1px 0 rgba(255,255,255,0.1),
        0 0 0 1px rgba(167,139,250,0.3);
    }
    .panel.minimized .panel-content {
      opacity: 0;
      visibility: hidden;
      pointer-events: none;
    }
    .panel.minimized .panel-icon {
      opacity: 1;
      visibility: visible;
    }
    .panel.minimized .minimize-btn {
      opacity: 0;
      pointer-events: none;
    }

    /* Panel Icon (shown when minimized) */
    .panel-icon {
      position: absolute;
      top: 0;
      left: 0;
      width: 48px;
      height: 48px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
      opacity: 0;
      visibility: hidden;
      transition: all 0.3s ease;
      z-index: 10;
    }
    
    /* Tooltip for minimized panels */
    .panel.minimized::after {
      content: attr(data-tooltip);
      position: absolute;
      left: 56px;
      top: 50%;
      transform: translateY(-50%);
      background: var(--ui);
      color: var(--fg);
      padding: 6px 10px;
      border-radius: 6px;
      font-size: 10px;
      font-weight: 600;
      white-space: nowrap;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s ease;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    }
    #ui-right.minimized::after {
      left: auto;
      right: 56px;
    }
    .panel.minimized:hover::after {
      opacity: 1;
    }

    /* Panel Content Wrapper */
    .panel-content {
      display: flex;
      flex-direction: column;
      gap: 6px;
      opacity: 1;
      visibility: visible;
      transition: opacity 0.3s ease, visibility 0.3s ease;
    }

    /* Minimize Button */
    .minimize-btn {
      position: absolute;
      top: 10px;
      right: 10px;
      width: 24px;
      height: 24px;
      border: none;
      background: rgba(255,255,255,0.05);
      color: #71717a;
      border-radius: 6px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      transition: all 0.2s ease;
      z-index: 20;
      opacity: 0;
    }
    .panel:hover .minimize-btn {
      opacity: 1;
    }
    .minimize-btn:hover {
      background: rgba(255,255,255,0.1);
      color: var(--fg);
      transform: scale(1.1);
    }

    /* Glass shimmer effect on hover */
    .panel:not(.minimized):hover {
      border-color: rgba(255,255,255,0.12);
      box-shadow: 
        var(--shadow),
        inset 0 1px 0 rgba(255,255,255,0.08),
        0 0 0 1px rgba(0,0,0,0.3),
        0 0 30px rgba(167,139,250,0.05);
    }

    /* Panel Header */
    .panel-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding-bottom: 10px;
      border-bottom: 1px solid var(--bd);
      margin-bottom: 8px;
    }
    .panel-header h2 {
      margin: 0;
      font-size: 11px;
      font-weight: 700;
      letter-spacing: 0.05em;
      text-transform: uppercase;
      color: var(--accent);
    }

    /* Tabs */
    .tabs {
      display: flex;
      gap: 2px;
      background: rgba(0,0,0,0.3);
      padding: 3px;
      border-radius: 8px;
      margin-bottom: 10px;
    }
    .tab {
      flex: 1;
      border: none;
      background: transparent;
      color: #71717a;
      cursor: pointer;
      padding: 7px 8px;
      border-radius: 6px;
      font-weight: 600;
      font-size: 10px;
      transition: all 0.2s;
    }
    .tab:hover { color: #a1a1aa; }
    .tab.active { 
      background: var(--ui); 
      color: var(--fg); 
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
    }

    /* Section */
    .section {
      background: rgba(0,0,0,0.2);
      border-radius: 8px;
      padding: 10px;
      margin-bottom: 8px;
    }
    .section-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      cursor: pointer;
      user-select: none;
    }
    .section-header h3 {
      margin: 0;
      font-size: 9px;
      font-weight: 700;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      color: #a1a1aa;
    }
    .section-toggle {
      font-size: 10px;
      color: #71717a;
      transition: transform 0.2s;
    }
    .section.collapsed .section-toggle { transform: rotate(-90deg); }
    .section.collapsed .section-content { display: none; }
    .section-content { margin-top: 10px; display: flex; flex-direction: column; gap: 6px; }

    /* Controls */
    .row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      font-size: 10px;
    }
    .row label { color: #a1a1aa; flex-shrink: 0; }

    button, select, input[type="text"] {
      background: var(--ui);
      color: var(--fg);
      border: 1px solid var(--bd);
      padding: 6px 10px;
      border-radius: 6px;
      font-size: 10px;
      font-family: inherit;
      outline: none;
      transition: all 0.15s;
    }
    button:hover, select:hover { border-color: #52525b; background: var(--ui-hover); }
    button:active { transform: translateY(1px); }
    select { cursor: pointer; }
    select option { background: var(--bg); }

    input[type="range"] {
      flex: 1;
      height: 4px;
      background: var(--bd);
      border-radius: 2px;
      appearance: none;
      cursor: pointer;
    }
    input[type="range"]::-webkit-slider-thumb {
      appearance: none;
      width: 12px;
      height: 12px;
      background: var(--accent);
      border-radius: 50%;
      cursor: grab;
      transition: transform 0.1s;
    }
    input[type="range"]::-webkit-slider-thumb:hover { transform: scale(1.2); }
    input[type="range"]::-webkit-slider-thumb:active { cursor: grabbing; }

    input[type="text"] {
      flex: 1;
      background: transparent;
      border-color: transparent;
      border-bottom-color: var(--bd);
      border-radius: 0;
      padding: 6px 2px;
    }
    input[type="text"]:focus { border-bottom-color: var(--accent); }

    input[type="checkbox"] {
      appearance: none;
      width: 16px;
      height: 16px;
      background: var(--ui);
      border: 1px solid var(--bd);
      border-radius: 4px;
      cursor: pointer;
      position: relative;
    }
    input[type="checkbox"]:checked {
      background: var(--accent);
      border-color: var(--accent);
    }
    input[type="checkbox"]:checked::after {
      content: '✓';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 10px;
      color: #000;
      font-weight: bold;
    }

    input[type="color"] {
      width: 28px;
      height: 28px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      padding: 0;
      background: transparent;
    }
    input[type="color"]::-webkit-color-swatch-wrapper { padding: 2px; }
    input[type="color"]::-webkit-color-swatch { border-radius: 4px; border: none; }

    hr { border: 0; border-top: 1px solid var(--bd); margin: 8px 0; }

    .btn-primary {
      background: linear-gradient(135deg, var(--accent) 0%, var(--accent-dim) 100%);
      color: #fff;
      font-weight: 700;
      border: none;
      padding: 10px 16px;
    }
    .btn-primary:hover { opacity: 0.9; box-shadow: 0 4px 15px rgba(167,139,250,0.3); }

    .btn-icon {
      width: 32px;
      height: 32px;
      padding: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
    }

    .group { display: flex; flex-direction: column; gap: 6px; }
    .hidden { display: none !important; }

    /* Texture Preview */
    #texture-monitor {
      margin-top: 10px;
      padding-top: 10px;
      border-top: 1px solid var(--bd);
    }
    #monitor-label {
      font-size: 8px;
      font-weight: 700;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      color: #71717a;
      margin-bottom: 8px;
      display: block;
    }
    #gl {
      width: 100%;
      aspect-ratio: 1;
      border-radius: 6px;
      border: 1px solid var(--bd);
      background: #000;
      image-rendering: pixelated;
    }

    /* Prompt Bar */
    #promptBar {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 60;
      display: flex;
      gap: 6px;
      padding: 6px;
      background: var(--glass);
      backdrop-filter: blur(20px);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 14px;
      box-shadow: var(--shadow);
      transition: all 0.3s cubic-bezier(0.16, 1, 0.3, 1);
    }
    #promptBar:focus-within {
      border-color: var(--accent);
      box-shadow: var(--shadow), 0 0 0 3px rgba(167,139,250,0.15);
    }
    #texturePrompt {
      width: 320px;
      background: transparent;
      border: none;
      outline: none;
      color: var(--fg);
      padding: 10px 12px;
      font-size: 12px;
    }
    #texturePrompt::placeholder { color: #52525b; }

    /* Presets Grid */
    .presets-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 6px;
    }
    .preset-btn {
      padding: 8px 4px;
      font-size: 8px;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    /* Loader */
    .loader {
      display: none;
      width: 14px;
      height: 14px;
      border: 2px solid rgba(255,255,255,0.2);
      border-left-color: currentColor;
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }
    @keyframes spin { 100% { transform: rotate(360deg); } }
    .loading .loader { display: inline-block; }
    .loading span { display: none; }

    /* Keyboard Shortcuts Hint */
    .shortcuts-hint {
      position: fixed;
      bottom: 80px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 9px;
      color: #52525b;
      display: flex;
      gap: 16px;
    }
    .shortcut kbd {
      background: var(--ui);
      padding: 2px 6px;
      border-radius: 4px;
      border: 1px solid var(--bd);
      font-family: inherit;
      margin-right: 4px;
    }

    /* ===== GENERATIVE UI - BOTTOM BAR ===== */
    #ui-bottom {
      position: fixed;
      bottom: 0;
      left: 50%;
      transform: translateX(-50%);
      width: 100%;
      max-width: 800px;
      z-index: 200;
      padding: 12px 20px 16px;
    }

    .gen-module {
      background: var(--glass, rgba(9,9,11,0.92));
      border: 1px solid var(--bd, #3f3f46);
      border-radius: var(--radius, 10px);
      padding: 12px 16px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
    }

    .gen-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .gen-title {
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: var(--fg, #fafafa);
    }

    .gen-status {
      font-size: 10px;
      color: var(--accent, #a78bfa);
      opacity: 0.8;
    }

    .gen-input-row {
      display: flex;
      gap: 8px;
    }

    .gen-prompt {
      flex: 1;
      background: var(--ui, #18181b);
      border: 1px solid var(--bd, #3f3f46);
      border-radius: 6px;
      padding: 10px 12px;
      font-size: 12px;
      color: var(--fg, #fafafa);
      outline: none;
      transition: border-color 0.2s;
      font-family: inherit;
    }

    .gen-prompt:focus {
      border-color: var(--accent, #a78bfa);
    }

    .gen-prompt:disabled {
      opacity: 0.5;
    }

    .gen-controls-row {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .gen-select {
      background: var(--ui, #18181b);
      border: 1px solid var(--bd, #3f3f46);
      border-radius: 6px;
      padding: 6px 10px;
      font-size: 10px;
      color: var(--fg, #fafafa);
      cursor: pointer;
      min-width: 100px;
    }

    .gen-button {
      background: var(--ui, #18181b);
      border: 1px solid var(--bd, #3f3f46);
      border-radius: 6px;
      padding: 8px 16px;
      font-size: 11px;
      font-weight: 600;
      color: var(--fg, #fafafa);
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      position: relative;
      min-width: 90px;
    }

    .gen-button.primary {
      background: var(--accent, #a78bfa);
      border-color: var(--accent, #a78bfa);
      color: #000;
    }

    .gen-button:hover:not(:disabled) {
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    }

    .gen-button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .gen-button.loading .gen-btn-text {
      opacity: 0;
    }

    .gen-button.loading .gen-btn-loader {
      display: block;
    }

    .gen-btn-loader {
      display: none;
      width: 14px;
      height: 14px;
      border: 2px solid transparent;
      border-top-color: currentColor;
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
      position: absolute;
    }

    .gen-output-row {
      display: flex;
      gap: 12px;
      align-items: flex-start;
      padding-top: 8px;
      border-top: 1px solid var(--bd, #3f3f46);
    }

    .gen-preview-container {
      width: 80px;
      height: 80px;
      border-radius: 6px;
      overflow: hidden;
      border: 1px solid var(--bd, #3f3f46);
      flex-shrink: 0;
    }

    .gen-preview {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .gen-apply-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      align-items: center;
    }

    .gen-apply-label {
      font-size: 10px;
      color: var(--fg, #fafafa);
      opacity: 0.6;
      width: 100%;
      margin-bottom: 2px;
    }

    .gen-apply-btn {
      background: var(--ui, #18181b);
      border: 1px solid var(--bd, #3f3f46);
      border-radius: 4px;
      padding: 4px 10px;
      font-size: 10px;
      color: var(--fg, #fafafa);
      cursor: pointer;
      transition: all 0.15s;
    }

    .gen-apply-btn:hover {
      background: var(--ui-hover, #27272a);
      border-color: var(--accent, #a78bfa);
    }

    .gen-apply-btn.active {
      background: var(--accent, #a78bfa);
      border-color: var(--accent, #a78bfa);
      color: #000;
    }

    .gen-history {
      display: flex;
      gap: 6px;
      overflow-x: auto;
      padding: 4px 0;
    }

    .gen-history-item {
      width: 48px;
      height: 48px;
      border-radius: 4px;
      overflow: hidden;
      border: 1px solid var(--bd, #3f3f46);
      cursor: pointer;
      flex-shrink: 0;
      transition: border-color 0.15s;
    }

    .gen-history-item:hover {
      border-color: var(--accent, #a78bfa);
    }

    .gen-history-item img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .gen-service-status {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 9px;
      opacity: 0.6;
    }

    .gen-service-dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: var(--danger, #f87171);
    }

    .gen-service-dot.online {
      background: var(--success, #34d399);
    }

  </style>

  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.171.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.171.0/examples/jsm/"
    }
  }
  </script>
</head>
<body>

  <!-- LEFT PANEL: POSTER CONTROLS -->
  <div id="ui-left" class="panel" data-tooltip="Poster Layout [1]">
    <div class="panel-icon">🎨</div>
    <button class="minimize-btn" title="Minimize panel">−</button>
    <div class="panel-content">
    <div class="panel-header">
      <h2>◈ Poster Layout</h2>
      <button id="btn-remix" class="btn-icon" title="Randomize Content">🎲</button>
    </div>

    <!-- Style Section -->
    <div class="section">
      <div class="section-header">
        <h3>Typography Style</h3>
        <span class="section-toggle">▼</span>
      </div>
      <div class="section-content">
        <select id="p-style">
          <optgroup label="Swiss / International">
            <option value="swiss">Swiss International</option>
            <option value="neuegrafik">Neue Grafik</option>
            <option value="werkbund">Werkbund</option>
            <option value="minimal">Minimalist</option>
          </optgroup>
          <optgroup label="Art Movements">
            <option value="bauhaus">Bauhaus</option>
            <option value="destijl">De Stijl</option>
            <option value="deco">Art Deco</option>
            <option value="nouveau">Art Nouveau</option>
            <option value="construct">Constructivist</option>
            <option value="avantgarde">Russian Avant-Garde</option>
            <option value="futurism">Futurism</option>
            <option value="dada">Dadaism</option>
          </optgroup>
          <optgroup label="Classic">
            <option value="editorial">Editorial</option>
            <option value="art">Gallery</option>
            <option value="retro">Retro Frame</option>
            <option value="streamline">Streamline Moderne</option>
          </optgroup>
          <optgroup label="Modern Digital">
            <option value="tech">Tech / HUD</option>
            <option value="brutal">Brutalist</option>
            <option value="cyberpunk">Cyberpunk</option>
            <option value="glitch">Glitch</option>
            <option value="kinetic">Kinetic / Op Art</option>
          </optgroup>
          <optgroup label="Expressive">
            <option value="acid">Acid Graphix</option>
            <option value="vaporwave">Vaporwave</option>
            <option value="psychedelic">Psychedelic 60s</option>
            <option value="popart">Pop Art</option>
            <option value="memphis">Memphis</option>
            <option value="grunge">Grunge</option>
            <option value="punk">Punk / DIY</option>
            <option value="postmodern">Postmodern</option>
          </optgroup>
          <optgroup label="Cultural">
            <option value="zen">Zen / Vertical</option>
            <option value="jpmod">Japanese Modern</option>
            <option value="concrete">Concrete Poetry</option>
          </optgroup>
        </select>
      </div>
    </div>

    <!-- Composition & Layout Section -->
    <div class="section">
      <div class="section-header">
        <h3>Composition</h3>
        <span class="section-toggle">▼</span>
      </div>
      <div class="section-content">
        <!-- Grid System -->
        <div style="margin-bottom:8px; padding-bottom:6px; border-bottom:1px solid var(--bd);">
          <div style="font-size:9px; text-transform:uppercase; letter-spacing:1px; color:var(--fg2); margin-bottom:4px;">Grid System</div>
        </div>
        <div class="row">
          <label>Show Grid</label>
          <input type="checkbox" id="grid-show">
        </div>
        <div class="row">
          <label>Columns</label>
          <input type="range" id="grid-cols" min="2" max="16" value="12" step="1">
          <span id="grid-cols-disp" style="min-width:20px; text-align:right; font-size:10px; color:var(--fg2);">12</span>
        </div>
        <div class="row">
          <label>Rows</label>
          <input type="range" id="grid-rows" min="2" max="16" value="8" step="1">
          <span id="grid-rows-disp" style="min-width:20px; text-align:right; font-size:10px; color:var(--fg2);">8</span>
        </div>
        <div class="row">
          <label>Gutter</label>
          <input type="range" id="grid-gutter" min="0" max="5" value="2" step="0.5">
        </div>
        <div class="row">
          <label>Margin</label>
          <input type="range" id="grid-margin" min="0" max="10" value="5" step="0.5">
        </div>
        <div class="row">
          <label>Edit Mode</label>
          <input type="checkbox" id="edit-mode">
          <span style="font-size:9px; color:var(--fg2); margin-left:4px;">Drag text</span>
        </div>
        <div class="row">
          <label>Snap to Grid</label>
          <input type="checkbox" id="snap-grid" checked>
        </div>
        
        <!-- Composition Guides -->
        <div style="margin-top:8px; padding-top:6px; border-top:1px solid var(--bd);">
          <div style="font-size:9px; text-transform:uppercase; letter-spacing:1px; color:var(--fg2); margin-bottom:4px;">Guides</div>
        </div>
        <div class="row">
          <label>Show Guide</label>
          <input type="checkbox" id="guide-show">
        </div>
        <div class="row">
          <label>Guide Type</label>
          <select id="guide-type">
            <option value="none">None</option>
            <option value="thirds">Rule of Thirds</option>
            <option value="golden">Golden Ratio</option>
            <option value="diagonal">Diagonal</option>
            <option value="center">Center Cross</option>
            <option value="phi">Phi Grid</option>
            <option value="fibonacci">Fibonacci Spiral</option>
          </select>
        </div>
        
        <!-- Text Alignment -->
        <div style="margin-top:8px; padding-top:6px; border-top:1px solid var(--bd);">
          <div style="font-size:9px; text-transform:uppercase; letter-spacing:1px; color:var(--fg2); margin-bottom:4px;">Text Layout</div>
        </div>
        <div class="row">
          <label>Alignment</label>
          <select id="comp-align">
            <option value="auto">Auto (Style)</option>
            <option value="left">Left</option>
            <option value="center">Center</option>
            <option value="right">Right</option>
          </select>
        </div>
        <div class="row">
          <label>Title Scale</label>
          <input type="range" id="comp-title-scale" min="0.5" max="2" value="1" step="0.05">
        </div>
        <div class="row">
          <label>Spacing</label>
          <input type="range" id="comp-spacing" min="0.5" max="2" value="1" step="0.1">
        </div>
        
        <!-- Layout Presets -->
        <div class="row" style="flex-wrap: wrap; gap: 4px; margin-top:8px;">
          <button class="preset-btn" data-layout="hero" style="flex:1; min-width:50px;">Hero</button>
          <button class="preset-btn" data-layout="split" style="flex:1; min-width:50px;">Split</button>
          <button class="preset-btn" data-layout="corner" style="flex:1; min-width:50px;">Corner</button>
          <button class="preset-btn" data-layout="full" style="flex:1; min-width:50px;">Full</button>
          <button class="preset-btn" data-layout="frame" style="flex:1; min-width:50px;">Frame</button>
        </div>
      </div>
    </div>

    <!-- Export Section -->
    <div class="section">
      <div class="section-header">
        <h3>Export</h3>
        <span class="section-toggle">▼</span>
      </div>
      <div class="section-content">
        <div class="row">
          <label>Resolution</label>
          <select id="export-res">
            <option value="1x">1x (Canvas Size)</option>
            <option value="2x" selected>2x (Print Ready)</option>
            <option value="3x">3x (High Res)</option>
            <option value="4x">4x (Ultra)</option>
          </select>
        </div>
        <div class="row">
          <label>Format</label>
          <select id="export-format">
            <option value="png" selected>PNG (Lossless)</option>
            <option value="jpg">JPG (Compressed)</option>
            <option value="webp">WebP (Modern)</option>
          </select>
        </div>
        <div class="row">
          <label>Quality</label>
          <input type="range" id="export-quality" min="0.7" max="1" value="0.95" step="0.05">
        </div>
        <div class="row" style="margin-top:10px;">
          <button id="export-poster" style="flex:1; padding:10px; font-weight:600; background:var(--fg); color:var(--bg); border:none; border-radius:4px; cursor:pointer;">Export Poster</button>
        </div>
        <div id="export-status" style="font-size:10px; color:var(--fg2); text-align:center; margin-top:6px;"></div>
      </div>
    </div>

    <!-- Format Section -->
    <div class="section">
      <div class="section-header">
        <h3>Format</h3>
        <span class="section-toggle">▼</span>
      </div>
      <div class="section-content">
        <div class="row">
          <label>Orientation</label>
          <select id="p-orient">
            <option value="portrait">Portrait (2:3)</option>
            <option value="landscape">Landscape (3:2)</option>
            <option value="square">Square (1:1)</option>
            <option value="wide">Wide (16:9)</option>
            <option value="ultrawide">Ultrawide (21:9)</option>
          </select>
        </div>
        <div class="row">
          <label>Color Profile</label>
          <select id="p-color">
            <option value="standard">Standard</option>
            <option value="vivid">Vivid</option>
            <option value="muted">Muted</option>
            <option value="print">Print CMYK Sim</option>
            <option value="bw">Monochrome</option>
            <option value="sepia">Sepia</option>
          </select>
        </div>
      </div>
    </div>

    <!-- Text Content Section -->
    <div class="section">
      <div class="section-header">
        <h3>Text Content</h3>
        <span class="section-toggle">▼</span>
      </div>
      <div class="section-content">
        <input type="text" id="t-title" placeholder="Title" value="GENERATIVE">
        <input type="text" id="t-meta" placeholder="Subtitle / Meta" value="FIG 01. — 2025">
        <input type="text" id="t-desc" placeholder="Description" value="Neural cellular automata exploring self-organizing patterns in digital space.">
        <div class="row" style="font-size:9px; color:#71717a;">
          <span>Signature:</span>
          <input type="text" id="t-sig" value="MonKnight" style="text-align:right; width:100px;">
        </div>
      </div>
    </div>

    <!-- Background Section -->
    <div class="section">
      <div class="section-header">
        <h3>Background</h3>
        <span class="section-toggle">▼</span>
      </div>
      <div class="section-content">
        <div class="row">
          <label>Type</label>
          <select id="bg-type">
            <option value="3d">3D Scene</option>
            <option value="gradient">Gradient</option>
            <option value="solid">Solid Color</option>
            <option value="noise">Noise Pattern</option>
          </select>
        </div>
        <div class="row" id="bg-color-row">
          <label>Color 1</label>
          <input type="color" id="bg-color1" value="#0a0a0f">
        </div>
        <div class="row" id="bg-color2-row">
          <label>Color 2</label>
          <input type="color" id="bg-color2" value="#1a1a2e">
        </div>
        <div class="row" id="bg-angle-row">
          <label>Angle</label>
          <input type="range" id="bg-angle" min="0" max="360" value="135">
        </div>
      </div>
    </div>

    <!-- Presets -->
    <div class="section">
      <div class="section-header">
        <h3>Quick Presets</h3>
        <span class="section-toggle">▼</span>
      </div>
      <div class="section-content">
        <div class="presets-grid">
          <button class="preset-btn" data-preset="techno">Techno</button>
          <button class="preset-btn" data-preset="gallery">Gallery</button>
          <button class="preset-btn" data-preset="poster">Event</button>
          <button class="preset-btn" data-preset="album">Album</button>
          <button class="preset-btn" data-preset="film">Film</button>
          <button class="preset-btn" data-preset="brand">Brand</button>
        </div>
      </div>
    </div>

    <button id="btn-export" class="btn-primary" style="margin-top:auto;">
      💾 EXPORT HQ POSTER
    </button>
    </div>
  </div>

  <!-- RIGHT PANEL: GENERATOR CONTROLS -->
  <div id="ui-right" class="panel" data-tooltip="Generator Engine [2]">
    <div class="panel-icon">⚙️</div>
    <button class="minimize-btn" title="Minimize panel">−</button>
    <div class="panel-content">
    <div class="panel-header">
      <h2>◈ Generator Engine</h2>
    </div>

    <div class="tabs">
      <button class="tab active" data-target="gen-visual">Visuals</button>
      <button class="tab" data-target="gen-sim">NCA Sim</button>
      <button class="tab" data-target="gen-anim">Animate</button>
    </div>

    <!-- Visuals Tab -->
    <div id="gen-visual" class="group">
      <div class="section">
        <div class="section-header">
          <h3>Geometry</h3>
          <span class="section-toggle">▼</span>
        </div>
        <div class="section-content">
          <select id="shape">
            <optgroup label="Primitives">
              <option value="torus">TorusKnot</option>
              <option value="sphere">Sphere</option>
              <option value="box">Cube</option>
              <option value="icosa">Icosahedron</option>
              <option value="octa">Octahedron</option>
              <option value="dodeca">Dodecahedron</option>
            </optgroup>
            <optgroup label="Extended">
              <option value="torus-simple">Torus</option>
              <option value="cylinder">Cylinder</option>
              <option value="cone">Cone</option>
              <option value="ring">Ring</option>
              <option value="capsule">Capsule</option>
            </optgroup>
            <optgroup label="Surfaces">
              <option value="plane">Plane</option>
              <option value="klein">Klein Bottle</option>
              <option value="mobius">Möbius Strip</option>
            </optgroup>
          </select>
          <div class="row">
            <label>Scale</label>
            <input type="range" id="geoScale" min="0.3" max="2" value="1" step="0.05">
          </div>
          <div class="row">
            <label>Complexity</label>
            <input type="range" id="geoDetail" min="1" max="4" value="2" step="1">
          </div>
        </div>
      </div>

      <!-- Camera & Lens Section -->
      <div class="section">
        <div class="section-header">
          <h3>Camera</h3>
          <span class="section-toggle">▼</span>
        </div>
        <div class="section-content">
          <div class="row">
            <label>FOV</label>
            <input type="range" id="cam-fov" min="15" max="120" value="45" step="1">
            <span id="cam-fov-disp" style="min-width:30px; text-align:right; font-size:10px;">45°</span>
          </div>
          <div class="row">
            <label>Distance</label>
            <input type="range" id="cam-distance" min="2" max="15" value="5" step="0.1">
          </div>
          <div class="row">
            <label>Height</label>
            <input type="range" id="cam-height" min="-3" max="5" value="0" step="0.1">
          </div>
          <div class="row">
            <label>Tilt</label>
            <input type="range" id="cam-tilt" min="-45" max="45" value="0" step="1">
          </div>
          <div class="row">
            <label>Roll</label>
            <input type="range" id="cam-roll" min="-30" max="30" value="0" step="1">
          </div>
          
          <!-- Lens Presets -->
          <div style="margin-top:8px; padding-top:6px; border-top:1px solid var(--bd);">
            <div style="font-size:9px; text-transform:uppercase; letter-spacing:1px; color:var(--fg2); margin-bottom:4px;">Lens Presets</div>
          </div>
          <div class="row" style="flex-wrap: wrap; gap: 4px;">
            <button class="preset-btn" data-cam="wide" style="flex:1; min-width:60px;" title="24mm Wide">Wide</button>
            <button class="preset-btn" data-cam="standard" style="flex:1; min-width:60px;" title="50mm Standard">50mm</button>
            <button class="preset-btn" data-cam="portrait" style="flex:1; min-width:60px;" title="85mm Portrait">85mm</button>
          </div>
          <div class="row" style="flex-wrap: wrap; gap: 4px; margin-top:4px;">
            <button class="preset-btn" data-cam="tele" style="flex:1; min-width:60px;" title="135mm Telephoto">Tele</button>
            <button class="preset-btn" data-cam="macro" style="flex:1; min-width:60px;" title="Macro Close-up">Macro</button>
            <button class="preset-btn" data-cam="dutch" style="flex:1; min-width:60px;" title="Dutch Angle">Dutch</button>
          </div>
          <div class="row" style="flex-wrap: wrap; gap: 4px; margin-top:4px;">
            <button class="preset-btn" data-cam="overhead" style="flex:1; min-width:60px;" title="Overhead View">Over</button>
            <button class="preset-btn" data-cam="lowangle" style="flex:1; min-width:60px;" title="Low Angle">Low</button>
            <button class="preset-btn" data-cam="cinematic" style="flex:1; min-width:60px;" title="Cinematic">Cine</button>
          </div>
        </div>
      </div>

      <div class="section">
        <div class="section-header">
          <h3>Material</h3>
          <span class="section-toggle">▼</span>
        </div>
        <div class="section-content">
          <div class="row">
            <label>Mapping</label>
            <select id="mapMode">
              <option value="albedo">Albedo</option>
              <option value="emissive">Emissive</option>
              <option value="displace">Displacement</option>
              <option value="albedo_displace">Albedo + Disp</option>
              <option value="emissive_displace">Emissive + Disp</option>
              <option value="normal">Normal Map</option>
            </select>
          </div>
          <div class="row">
            <label>Roughness</label>
            <input type="range" id="matRough" min="0" max="1" value="0.45" step="0.01">
          </div>
          <div class="row">
            <label>Metalness</label>
            <input type="range" id="matMetal" min="0" max="1" value="0.15" step="0.01">
          </div>
          <div class="row">
            <label>Displacement</label>
            <input type="range" id="disp" min="0" max="1.5" value="0.3" step="0.01">
          </div>
          <div class="row">
            <label>Wireframe</label>
            <input type="checkbox" id="wire">
          </div>
        </div>
      </div>

      <div class="section">
        <div class="section-header">
          <h3>Texture</h3>
          <span class="section-toggle">▼</span>
        </div>
        <div class="section-content">
          <div class="row">
            <label>Repeat</label>
            <input type="range" id="texRepeat" min="1" max="12" value="1" step="0.5">
          </div>
          <div class="row">
            <label>Rotate</label>
            <input type="range" id="texRotate" min="0" max="6.28" value="0" step="0.05">
          </div>
          <div class="row">
            <label>Offset X</label>
            <input type="range" id="texOffsetX" min="0" max="1" value="0" step="0.01">
          </div>
          <div class="row">
            <label>Offset Y</label>
            <input type="range" id="texOffsetY" min="0" max="1" value="0" step="0.01">
          </div>
        </div>
      </div>

      <div class="section">
        <div class="section-header">
          <h3>Effects</h3>
          <span class="section-toggle">▼</span>
        </div>
        <div class="section-content">
          <div class="row">
            <label>Color Map</label>
            <select id="colormap">
              <option value="ice">Ice</option>
              <option value="fire">Fire</option>
              <option value="plasma">Plasma</option>
              <option value="viridis">Viridis</option>
              <option value="magma">Magma</option>
              <option value="mono">Monochrome</option>
              <option value="original">Original</option>
            </select>
          </div>
          
          <!-- Bloom -->
          <div style="margin-top:8px; padding-top:6px; border-top:1px solid var(--bd);">
            <div style="font-size:9px; text-transform:uppercase; letter-spacing:1px; color:var(--fg2); margin-bottom:4px;">Bloom</div>
          </div>
          <div class="row">
            <label>Strength</label>
            <input type="range" id="bloomStrength" min="0" max="2.5" value="0.65" step="0.01">
          </div>
          <div class="row">
            <label>Radius</label>
            <input type="range" id="bloomRadius" min="0" max="2" value="0.5" step="0.01">
          </div>
          <div class="row">
            <label>Threshold</label>
            <input type="range" id="bloomThreshold" min="0" max="1" value="0.15" step="0.01">
          </div>
          
          <!-- Chromatic Aberration -->
          <div style="margin-top:8px; padding-top:6px; border-top:1px solid var(--bd);">
            <div style="font-size:9px; text-transform:uppercase; letter-spacing:1px; color:var(--fg2); margin-bottom:4px;">Chromatic Aberration</div>
          </div>
          <div class="row">
            <label>Enable</label>
            <input type="checkbox" id="chromaEnabled">
          </div>
          <div class="row">
            <label>Offset</label>
            <input type="range" id="chromaOffset" min="0" max="0.02" value="0.003" step="0.0005">
          </div>
          <div class="row">
            <label>Radial Falloff</label>
            <input type="range" id="chromaFalloff" min="0" max="1" value="0.5" step="0.05">
          </div>
          
          <!-- Glitch Effect -->
          <div style="margin-top:8px; padding-top:6px; border-top:1px solid var(--bd);">
            <div style="font-size:9px; text-transform:uppercase; letter-spacing:1px; color:var(--fg2); margin-bottom:4px;">Glitch</div>
          </div>
          <div class="row">
            <label>Enable</label>
            <input type="checkbox" id="glitchEnabled">
          </div>
          <div class="row">
            <label>Intensity</label>
            <input type="range" id="glitchIntensity" min="0" max="1" value="0.3" step="0.05">
          </div>
          <div class="row">
            <label>Speed</label>
            <input type="range" id="glitchSpeed" min="0.1" max="5" value="1" step="0.1">
          </div>
          <div class="row">
            <label>Block Size</label>
            <input type="range" id="glitchBlock" min="1" max="50" value="16" step="1">
          </div>
          
          <!-- God Rays -->
          <div style="margin-top:8px; padding-top:6px; border-top:1px solid var(--bd);">
            <div style="font-size:9px; text-transform:uppercase; letter-spacing:1px; color:var(--fg2); margin-bottom:4px;">God Rays</div>
          </div>
          <div class="row">
            <label>Enable</label>
            <input type="checkbox" id="godraysEnabled">
          </div>
          <div class="row">
            <label>Intensity</label>
            <input type="range" id="godraysIntensity" min="0" max="2" value="0.8" step="0.05">
          </div>
          <div class="row">
            <label>Decay</label>
            <input type="range" id="godraysDecay" min="0.8" max="1" value="0.95" step="0.01">
          </div>
          <div class="row">
            <label>Samples</label>
            <input type="range" id="godraysSamples" min="10" max="100" value="60" step="5">
          </div>
          
          <!-- Film Effects -->
          <div style="margin-top:8px; padding-top:6px; border-top:1px solid var(--bd);">
            <div style="font-size:9px; text-transform:uppercase; letter-spacing:1px; color:var(--fg2); margin-bottom:4px;">Film</div>
          </div>
          <div class="row">
            <label>Vignette</label>
            <input type="range" id="vignette" min="0" max="1" value="0.3" step="0.01">
          </div>
          <div class="row">
            <label>Film Grain</label>
            <input type="range" id="grain" min="0" max="0.5" value="0" step="0.01">
          </div>
          <div class="row">
            <label>Scanlines</label>
            <input type="range" id="scanlines" min="0" max="1" value="0" step="0.05">
          </div>
          <div class="row">
            <label>Sensors</label>
            <input type="checkbox" id="showSensors" checked>
          </div>
          
          <!-- Effect Presets -->
          <div class="row" style="flex-wrap: wrap; gap: 4px; margin-top:8px;">
            <button class="preset-btn" data-fx="clean" style="flex:1; min-width:50px;">Clean</button>
            <button class="preset-btn" data-fx="cinematic" style="flex:1; min-width:50px;">Film</button>
            <button class="preset-btn" data-fx="neon" style="flex:1; min-width:50px;">Neon</button>
            <button class="preset-btn" data-fx="retro" style="flex:1; min-width:50px;">Retro</button>
            <button class="preset-btn" data-fx="cyber" style="flex:1; min-width:50px;">Cyber</button>
          </div>
        </div>
      </div>

      <!-- CAMERA & LENS -->
      <div class="section">
        <div class="section-header">
          <h3>📷 Camera</h3>
          <span class="section-toggle">▼</span>
        </div>
        <div class="section-content">
          <div class="row">
            <label>FOV</label>
            <input type="range" id="cameraFov" min="15" max="120" value="45" step="1">
          </div>
          <div class="row">
            <label>Distance</label>
            <input type="range" id="cameraDist" min="2" max="15" value="5" step="0.1">
          </div>
          <div class="row">
            <label>Height</label>
            <input type="range" id="cameraHeight" min="-3" max="5" value="2" step="0.1">
          </div>
          <div class="row">
            <label>Tilt</label>
            <input type="range" id="cameraTilt" min="-45" max="45" value="0" step="1">
          </div>
          <div class="row">
            <label>Roll</label>
            <input type="range" id="cameraRoll" min="-30" max="30" value="0" step="1">
          </div>
          <div class="row" style="flex-wrap: wrap; gap: 4px; margin-top:6px;">
            <button class="preset-btn" data-cam="wide" style="flex:1; min-width:48px;">Wide</button>
            <button class="preset-btn" data-cam="standard" style="flex:1; min-width:48px;">50mm</button>
            <button class="preset-btn" data-cam="portrait" style="flex:1; min-width:48px;">85mm</button>
            <button class="preset-btn" data-cam="tele" style="flex:1; min-width:48px;">135mm</button>
            <button class="preset-btn" data-cam="macro" style="flex:1; min-width:48px;">Macro</button>
            <button class="preset-btn" data-cam="dutch" style="flex:1; min-width:48px;">Dutch</button>
          </div>
        </div>
      </div>

      <!-- LIGHTING -->
      <div class="section">
        <div class="section-header">
          <h3>💡 Lighting</h3>
          <span class="section-toggle">▼</span>
        </div>
        <div class="section-content">
          <div class="row">
            <label>Key Light</label>
            <input type="range" id="lightKey" min="0" max="3" value="1.8" step="0.1">
          </div>
          <div class="row">
            <label>Fill Light</label>
            <input type="range" id="lightFill" min="0" max="1.5" value="0.4" step="0.05">
          </div>
          <div class="row">
            <label>Rim Light</label>
            <input type="range" id="lightRim" min="0" max="1.5" value="0.3" step="0.05">
          </div>
          <div class="row">
            <label>Ambient</label>
            <input type="range" id="lightAmbient" min="0" max="2" value="1" step="0.1">
          </div>
          
          <!-- Spotlight -->
          <div style="margin-top:8px; padding-top:6px; border-top:1px solid var(--bd);">
            <div style="font-size:9px; text-transform:uppercase; letter-spacing:1px; color:var(--fg2); margin-bottom:4px;">Spotlight</div>
          </div>
          <div class="row">
            <label>Enable</label>
            <input type="checkbox" id="spotEnabled">
          </div>
          <div class="row">
            <label>Intensity</label>
            <input type="range" id="spotIntensity" min="0" max="5" value="2" step="0.1">
          </div>
          <div class="row">
            <label>Angle</label>
            <input type="range" id="spotAngle" min="5" max="90" value="30" step="1">
          </div>
          <div class="row">
            <label>Penumbra</label>
            <input type="range" id="spotPenumbra" min="0" max="1" value="0.5" step="0.05">
          </div>
          <div class="row">
            <label>Color</label>
            <input type="color" id="spotColor" value="#ffffff" style="width:40px; height:22px; border:1px solid var(--bd); border-radius:4px; cursor:pointer;">
          </div>
          
          <!-- Lighting Presets -->
          <div class="row" style="flex-wrap: wrap; gap: 4px; margin-top:8px;">
            <button class="preset-btn" data-light="studio" style="flex:1; min-width:52px;">Studio</button>
            <button class="preset-btn" data-light="dramatic" style="flex:1; min-width:52px;">Drama</button>
            <button class="preset-btn" data-light="neon" style="flex:1; min-width:52px;">Neon</button>
            <button class="preset-btn" data-light="rim" style="flex:1; min-width:52px;">Rim</button>
            <button class="preset-btn" data-light="ambient" style="flex:1; min-width:52px;">Soft</button>
          </div>
        </div>
      </div>

      <!-- SCENE -->
      <div class="section">
        <div class="section-header">
          <h3>🎭 Scene</h3>
          <span class="section-toggle">▼</span>
        </div>
        <div class="section-content">
          <!-- Floor -->
          <div class="row">
            <label>Show Floor</label>
            <input type="checkbox" id="floorEnabled">
          </div>
          <div class="row">
            <label>Floor Type</label>
            <select id="floorType">
              <option value="grid">Grid</option>
              <option value="solid">Solid</option>
              <option value="reflect">Reflective</option>
              <option value="gradient">Gradient</option>
              <option value="checker">Checkerboard</option>
            </select>
          </div>
          <div class="row">
            <label>Floor Color</label>
            <input type="color" id="floorColor" value="#1a1a2e" style="width:40px; height:22px; border:1px solid var(--bd); border-radius:4px; cursor:pointer;">
          </div>
          <div class="row">
            <label>Floor Opacity</label>
            <input type="range" id="floorOpacity" min="0" max="1" value="0.5" step="0.05">
          </div>
          <div class="row">
            <label>Floor Y</label>
            <input type="range" id="floorY" min="-3" max="0" value="-1.5" step="0.1">
          </div>
          
          <!-- Background Presets -->
          <div style="margin-top:8px; padding-top:6px; border-top:1px solid var(--bd);">
            <div style="font-size:9px; text-transform:uppercase; letter-spacing:1px; color:var(--fg2); margin-bottom:4px;">Background Presets</div>
          </div>
          <div class="row" style="flex-wrap: wrap; gap: 4px;">
            <button class="preset-btn" data-bg="dark" style="flex:1; min-width:50px;">Dark</button>
            <button class="preset-btn" data-bg="midnight" style="flex:1; min-width:50px;">Night</button>
            <button class="preset-btn" data-bg="sunset" style="flex:1; min-width:50px;">Sunset</button>
            <button class="preset-btn" data-bg="ocean" style="flex:1; min-width:50px;">Ocean</button>
            <button class="preset-btn" data-bg="neon" style="flex:1; min-width:50px;">Neon</button>
          </div>
        </div>
      </div>

      <div class="row">
        <button id="reset-cam">↺ Reset Camera</button>
      </div>
    </div>

    <!-- NCA Sim Tab -->
    <div id="gen-sim" class="group hidden">
      <div class="section">
        <div class="section-header">
          <h3>Simulation</h3>
          <span class="section-toggle">▼</span>
        </div>
        <div class="section-content">
          <div class="row">
            <button id="reset">Reset</button>
            <button id="step">Step</button>
            <label style="margin-left:auto;">Pause</label>
            <input type="checkbox" id="pause">
          </div>
          <div class="row">
            <label>Speed</label>
            <input type="range" id="speed" min="0" max="3" value="1" step="0.05">
          </div>
          <div class="row">
            <label>Noise</label>
            <input type="range" id="noise" min="0" max="0.8" value="0.14" step="0.01">
          </div>
          <div class="row">
            <label>Attractor</label>
            <input type="range" id="attractor" min="0" max="0.6" value="0.12" step="0.01">
          </div>
        </div>
      </div>

      <div class="section">
        <div class="section-header">
          <h3>Initialization</h3>
          <span class="section-toggle">▼</span>
        </div>
        <div class="section-content">
          <div class="row">
            <label>Seed Pattern</label>
            <select id="seed">
              <option value="random">Random</option>
              <option value="disk">Center Disk</option>
              <option value="rings">Rings</option>
              <option value="gradient">Gradient</option>
              <option value="checkerboard">Checkerboard</option>
              <option value="noise">Perlin Noise</option>
            </select>
          </div>
          <div class="row">
            <label>Mode</label>
            <select id="mode">
              <option value="glyph">Grow-to-Target</option>
              <option value="free">Free Grow</option>
            </select>
          </div>
          <div class="row">
            <label>NCA Preset</label>
            <select id="ncaPreset">
              <option value="0">Pattern A</option>
              <option value="1">Pattern B</option>
            </select>
          </div>
        </div>
      </div>

      <div id="texture-monitor">
        <span id="monitor-label">NCA State Monitor</span>
        <canvas id="gl" width="512" height="512"></canvas>
      </div>
    </div>

    <!-- Animation Tab -->
    <div id="gen-anim" class="group hidden">
      <div class="section">
        <div class="section-header">
          <h3>Animation</h3>
          <span class="section-toggle">▼</span>
        </div>
        <div class="section-content">
          <div class="row">
            <label>Rotation</label>
            <input type="checkbox" id="anim-rotate" checked>
          </div>
          <div class="row">
            <label>Rot. Speed</label>
            <input type="range" id="anim-rot-speed" min="0" max="0.02" value="0.003" step="0.0005">
          </div>
          <div class="row">
            <label>Float</label>
            <input type="checkbox" id="anim-float">
          </div>
          <div class="row">
            <label>Float Amp</label>
            <input type="range" id="anim-float-amp" min="0" max="0.5" value="0.1" step="0.01">
          </div>
          <div class="row">
            <label>Pulse</label>
            <input type="checkbox" id="anim-pulse">
          </div>
        </div>
      </div>

      <!-- PHYSICS MODULE -->
      <div class="section">
        <div class="section-header">
          <h3>⚛ Physics</h3>
          <span class="section-toggle">▼</span>
        </div>
        <div class="section-content">
          <div class="row">
            <label>Enable Physics</label>
            <input type="checkbox" id="physics-enabled">
          </div>
          <div class="row">
            <label>Gravity</label>
            <input type="range" id="phys-gravity" min="-2" max="2" value="0" step="0.05">
          </div>
          <div class="row">
            <label>Viscosity</label>
            <input type="range" id="phys-viscosity" min="0" max="1" value="0.2" step="0.02">
          </div>
          <div class="row">
            <label>Attraction</label>
            <input type="range" id="phys-attraction" min="0" max="2" value="0.5" step="0.05">
          </div>
          <div class="row">
            <label>Repulsion</label>
            <input type="range" id="phys-repulsion" min="0" max="2" value="0.3" step="0.05">
          </div>
          <div class="row">
            <label>Turbulence</label>
            <input type="range" id="phys-turbulence" min="0" max="3" value="0.5" step="0.1">
          </div>
          <div class="row">
            <label>Turb. Speed</label>
            <input type="range" id="phys-turb-speed" min="0.1" max="3" value="1" step="0.1">
          </div>
          <div class="row" style="flex-wrap: wrap; gap: 4px;">
            <button class="preset-btn" data-phys="smoke" style="flex:1; min-width:60px;">Smoke</button>
            <button class="preset-btn" data-phys="fluid" style="flex:1; min-width:60px;">Fluid</button>
            <button class="preset-btn" data-phys="dust" style="flex:1; min-width:60px;">Dust</button>
            <button class="preset-btn" data-phys="fire" style="flex:1; min-width:60px;">Fire</button>
            <button class="preset-btn" data-phys="orbit" style="flex:1; min-width:60px;">Orbit</button>
          </div>
        </div>
      </div>

      <!-- PARTICLE SYSTEM MODULE -->
      <div class="section">
        <div class="section-header">
          <h3>✨ Particles</h3>
          <span class="section-toggle">▼</span>
        </div>
        <div class="section-content">
          <div class="row">
            <label>Enable Particles</label>
            <input type="checkbox" id="particles-enabled">
          </div>
          <div class="row">
            <label>Count</label>
            <input type="range" id="particle-count" min="1000" max="50000" value="5000" step="1000">
            <span id="particle-count-disp" style="min-width:35px; text-align:right; font-size:10px; color:var(--fg2);">5k</span>
          </div>
          <div class="row">
            <label>Size</label>
            <input type="range" id="particle-size" min="0.1" max="3" value="0.5" step="0.1">
          </div>
          <div class="row">
            <label>Shape</label>
            <select id="particle-shape">
              <option value="point">Point</option>
              <option value="circle">Circle</option>
              <option value="ring">Ring</option>
              <option value="square">Square</option>
              <option value="diamond">Diamond</option>
              <option value="star">Star</option>
              <option value="heart">Heart</option>
              <option value="cross">Cross</option>
            </select>
          </div>
          <div class="row">
            <label>Constraint</label>
            <select id="particle-constraint">
              <option value="sphere">Sphere</option>
              <option value="box">Box</option>
              <option value="torus">Torus</option>
              <option value="plane">Plane</option>
              <option value="cylinder">Cylinder</option>
              <option value="cone">Cone</option>
              <option value="spiral">Spiral</option>
              <option value="none">None</option>
            </select>
          </div>
          <div class="row">
            <label>Const. Scale</label>
            <input type="range" id="particle-constraint-scale" min="0.5" max="8" value="2" step="0.1">
          </div>
          <div class="row">
            <label>Speed</label>
            <input type="range" id="particle-speed" min="0" max="2" value="0.5" step="0.05">
          </div>
          <div class="row">
            <label>Primary Color</label>
            <input type="color" id="particle-color1" value="#7dd3fc" style="width:40px; height:22px; border:1px solid var(--bd); border-radius:4px; cursor:pointer;">
          </div>
          <div class="row">
            <label>Secondary Color</label>
            <input type="color" id="particle-color2" value="#a78bfa" style="width:40px; height:22px; border:1px solid var(--bd); border-radius:4px; cursor:pointer;">
          </div>
          
          <!-- Optical Properties Sub-section -->
          <div style="margin-top:8px; padding-top:8px; border-top:1px solid var(--bd);">
            <div style="font-size:9px; text-transform:uppercase; letter-spacing:1px; color:var(--fg2); margin-bottom:6px;">Optical</div>
            <div class="row">
              <label>Focal Length</label>
              <input type="range" id="particle-focal" min="18" max="200" value="50" step="1">
            </div>
            <div class="row">
              <label>Aperture (f)</label>
              <input type="range" id="particle-aperture" min="1" max="16" value="2.8" step="0.1">
            </div>
            <div class="row">
              <label>Focus Dist.</label>
              <input type="range" id="particle-focus" min="0.5" max="20" value="5" step="0.5">
            </div>
            <div class="row">
              <label>Bloom</label>
              <input type="range" id="particle-bloom" min="0" max="2" value="0.8" step="0.1">
            </div>
          </div>
          
          <!-- Particle Presets -->
          <div class="row" style="flex-wrap: wrap; gap: 4px; margin-top:8px;">
            <button class="preset-btn" data-part="nebula" style="flex:1; min-width:50px;">Nebula</button>
            <button class="preset-btn" data-part="galaxy" style="flex:1; min-width:50px;">Galaxy</button>
            <button class="preset-btn" data-part="sparks" style="flex:1; min-width:50px;">Sparks</button>
            <button class="preset-btn" data-part="dust" style="flex:1; min-width:50px;">Dust</button>
            <button class="preset-btn" data-part="bokeh" style="flex:1; min-width:50px;">Bokeh</button>
            <button class="preset-btn" data-part="stars" style="flex:1; min-width:50px;">Stars</button>
            <button class="preset-btn" data-part="firefly" style="flex:1; min-width:50px;">Firefly</button>
            <button class="preset-btn" data-part="snow" style="flex:1; min-width:50px;">Snow</button>
          </div>
        </div>
      </div>

      <div class="section">
        <div class="section-header">
          <h3>Export Animation</h3>
          <span class="section-toggle">▼</span>
        </div>
        <div class="section-content">
          <div class="row">
            <label>Duration</label>
            <select id="anim-duration">
              <option value="2">2 seconds</option>
              <option value="4">4 seconds</option>
              <option value="6">6 seconds</option>
              <option value="10">10 seconds</option>
            </select>
          </div>
          <div class="row">
            <label>FPS</label>
            <select id="anim-fps">
              <option value="24">24 fps</option>
              <option value="30">30 fps</option>
              <option value="60">60 fps</option>
            </select>
          </div>
          <button id="btn-export-gif" class="btn-primary" style="margin-top:10px;">
            🎬 Export GIF (Coming Soon)
          </button>
        </div>
      </div>
    </div>
    </div>
  </div>

  <!-- TEXTURE PROMPT BAR -->
  <div id="promptBar">
    <input id="texturePrompt" type="text" placeholder="Generate seamless texture... (e.g., 'alien organic surface')" autocomplete="off" />
    <button id="btnGenerate">
      <div class="loader"></div>
      <span>Generate</span>
    </button>
  </div>

  <!-- KEYBOARD SHORTCUTS -->
  <div class="shortcuts-hint">
    <span class="shortcut"><kbd>R</kbd> Remix</span>
    <span class="shortcut"><kbd>S</kbd> Save</span>
    <span class="shortcut"><kbd>Space</kbd> Pause</span>
    <span class="shortcut"><kbd>1</kbd> Left Panel</span>
    <span class="shortcut"><kbd>2</kbd> Right Panel</span>
    <span class="shortcut"><kbd>Esc</kbd> Hide All</span>
  </div>

  <!-- MAIN POSTER -->
  <div id="poster-container">
    <canvas id="bg-layer"></canvas>
    <canvas id="geo"></canvas>
    
    <div id="typo-layer" class="style-swiss">
      <div class="title" id="d-title">GENERATIVE</div>
      <div class="meta" id="d-meta">FIG 01. — 2025</div>
      <div class="desc" id="d-desc">Neural cellular automata exploring self-organizing patterns in digital space.</div>
      <div class="sig">
        <span id="d-sig">MonKnight</span>
        <span id="d-id">:: ID 0X25</span>
      </div>
    </div>
    
    <!-- Grid Overlay -->
    <div id="grid-overlay"></div>
    
    <!-- Composition Guides -->
    <div id="comp-guides"></div>
    
    <!-- Snap Indicators -->
    <div id="snap-h" class="snap-indicator h" style="display:none;"></div>
    <div id="snap-v" class="snap-indicator v" style="display:none;"></div>
  </div>

  <!-- BOTTOM BAR: Generative Input UI -->
  <div id="ui-bottom">
    <div class="gen-module" id="generative-module">
      <div class="gen-header">
        <span class="gen-title">mflux Image Generator</span>
        <div class="gen-service-status">
          <span class="gen-service-dot" id="gen-service-dot"></span>
          <span id="gen-service-label">Checking...</span>
        </div>
        <span class="gen-status" id="gen-status">Ready</span>
      </div>

      <div class="gen-input-row">
        <input
          type="text"
          id="gen-prompt"
          class="gen-prompt"
          placeholder="Describe your image... (e.g., 'alien organic surface', 'neon grid pattern')"
          autocomplete="off"
        />
      </div>

      <div class="gen-controls-row">
        <select id="gen-style" class="gen-select">
          <option value="texture">Seamless Texture</option>
          <option value="abstract">Abstract</option>
          <option value="pattern">Pattern</option>
          <option value="photorealistic">Photorealistic</option>
          <option value="illustration">Illustration</option>
          <option value="cinematic">Cinematic</option>
          <option value="minimal">Minimal</option>
          <option value="raw">Raw (No Style)</option>
        </select>

        <select id="gen-size" class="gen-select">
          <option value="512x512">512x512</option>
          <option value="768x768">768x768</option>
          <option value="1024x1024">1024x1024</option>
          <option value="512x768">512x768 (Portrait)</option>
          <option value="768x512">768x512 (Landscape)</option>
        </select>

        <select id="gen-model" class="gen-select">
          <option value="flux-schnell">Schnell (Fast)</option>
          <option value="flux-dev">Dev (Quality)</option>
        </select>

        <button id="gen-submit" class="gen-button primary">
          <span class="gen-btn-text">Generate</span>
          <span class="gen-btn-loader"></span>
        </button>
      </div>

      <div class="gen-output-row" id="gen-output" style="display: none;">
        <div class="gen-preview-container">
          <img id="gen-preview" class="gen-preview" alt="Generated image" />
        </div>

        <div class="gen-apply-controls">
          <span class="gen-apply-label">Apply to:</span>
          <button class="gen-apply-btn" data-target="background">Background</button>
          <button class="gen-apply-btn" data-target="texture">Texture</button>
          <button class="gen-apply-btn" data-target="displacement">Displacement</button>
          <button class="gen-apply-btn" data-target="emissive">Emissive</button>
        </div>
      </div>

      <div class="gen-history" id="gen-history">
        <!-- History thumbnails will be added here -->
      </div>
    </div>
  </div>

  <script type="module">
  import * as THREE from 'three';
  import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
  import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
  import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
  import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
  import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
  import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
  import { ParametricGeometry } from 'three/addons/geometries/ParametricGeometry.js';

  // ===== GLOBAL STATE (must be at top) =====
  const effectsState = {
    chromaEnabled: false,
    chromaOffset: 0.003,
    chromaFalloff: 0.5,
    glitchEnabled: false,
    glitchIntensity: 0.3,
    glitchSpeed: 1,
    glitchBlock: 16,
    godraysEnabled: false,
    godraysIntensity: 0.8,
    godraysDecay: 0.95,
    godraysSamples: 60,
    scanlines: 0,
    vignette: 0.3,
    grain: 0
  };

  const cameraState = {
    fov: 45,
    distance: 5,
    height: 0,
    tilt: 0,
    roll: 0
  };

  const cameraPresets = {
    wide: { fov: 75, distance: 6, height: 0, tilt: 0, roll: 0, name: '24mm Wide' },
    standard: { fov: 45, distance: 5, height: 0, tilt: 0, roll: 0, name: '50mm Standard' },
    portrait: { fov: 35, distance: 4, height: 0.2, tilt: 0, roll: 0, name: '85mm Portrait' },
    tele: { fov: 25, distance: 8, height: 0, tilt: 0, roll: 0, name: '135mm Telephoto' },
    macro: { fov: 50, distance: 2.5, height: -0.5, tilt: 10, roll: 0, name: 'Macro Close-up' },
    dutch: { fov: 45, distance: 5, height: 0, tilt: 0, roll: 15, name: 'Dutch Angle' },
    overhead: { fov: 60, distance: 4, height: 3, tilt: -35, roll: 0, name: 'Overhead' },
    lowangle: { fov: 55, distance: 4, height: -1.5, tilt: 20, roll: 0, name: 'Low Angle' },
    dramatic: { fov: 30, distance: 6, height: 1, tilt: -10, roll: 8, name: 'Dramatic' },
    cinematic: { fov: 40, distance: 5.5, height: 0.3, tilt: -5, roll: 0, name: 'Cinematic 2.39:1' }
  };

  // ===== CUSTOM EFFECTS SHADER =====
  const CustomEffectsShader = {
    uniforms: {
      tDiffuse: { value: null },
      uTime: { value: 0 },
      uResolution: { value: new THREE.Vector2(1, 1) },
      // Chromatic Aberration
      uChromaEnabled: { value: false },
      uChromaOffset: { value: 0.003 },
      uChromaFalloff: { value: 0.5 },
      // Glitch
      uGlitchEnabled: { value: false },
      uGlitchIntensity: { value: 0.3 },
      uGlitchSpeed: { value: 1.0 },
      uGlitchBlock: { value: 16.0 },
      // God Rays
      uGodraysEnabled: { value: false },
      uGodraysIntensity: { value: 0.8 },
      uGodraysDecay: { value: 0.95 },
      uGodraysSamples: { value: 60 },
      uLightPos: { value: new THREE.Vector2(0.5, 0.3) },
      // Film Effects
      uVignette: { value: 0.3 },
      uGrain: { value: 0.0 },
      uScanlines: { value: 0.0 }
    },
    vertexShader: `
      varying vec2 vUv;
      void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `,
    fragmentShader: `
      uniform sampler2D tDiffuse;
      uniform float uTime;
      uniform vec2 uResolution;
      
      // Chromatic Aberration
      uniform bool uChromaEnabled;
      uniform float uChromaOffset;
      uniform float uChromaFalloff;
      
      // Glitch
      uniform bool uGlitchEnabled;
      uniform float uGlitchIntensity;
      uniform float uGlitchSpeed;
      uniform float uGlitchBlock;
      
      // God Rays
      uniform bool uGodraysEnabled;
      uniform float uGodraysIntensity;
      uniform float uGodraysDecay;
      uniform float uGodraysSamples;
      uniform vec2 uLightPos;
      
      // Film Effects
      uniform float uVignette;
      uniform float uGrain;
      uniform float uScanlines;
      
      varying vec2 vUv;
      
      // Random functions
      float random(vec2 st) {
        return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
      }
      
      float noise(vec2 st) {
        vec2 i = floor(st);
        vec2 f = fract(st);
        float a = random(i);
        float b = random(i + vec2(1.0, 0.0));
        float c = random(i + vec2(0.0, 1.0));
        float d = random(i + vec2(1.0, 1.0));
        vec2 u = f * f * (3.0 - 2.0 * f);
        return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
      }
      
      void main() {
        vec2 uv = vUv;
        vec4 color;
        
        // ===== GLITCH EFFECT =====
        if (uGlitchEnabled && uGlitchIntensity > 0.0) {
          float glitchTime = uTime * uGlitchSpeed;
          float blockY = floor(uv.y * uGlitchBlock);
          float glitchRand = random(vec2(blockY, floor(glitchTime * 10.0)));
          
          if (glitchRand > 1.0 - uGlitchIntensity * 0.3) {
            float offset = (random(vec2(glitchTime, blockY)) - 0.5) * uGlitchIntensity * 0.1;
            uv.x += offset;
          }
          
          // Color channel split on glitch
          if (random(vec2(glitchTime * 0.5, 0.0)) > 0.97) {
            float split = uGlitchIntensity * 0.02;
            color.r = texture2D(tDiffuse, uv + vec2(split, 0.0)).r;
            color.g = texture2D(tDiffuse, uv).g;
            color.b = texture2D(tDiffuse, uv - vec2(split, 0.0)).b;
            color.a = texture2D(tDiffuse, uv).a;
          } else {
            color = texture2D(tDiffuse, uv);
          }
        }
        
        // ===== CHROMATIC ABERRATION =====
        if (uChromaEnabled && uChromaOffset > 0.0) {
          vec2 center = vec2(0.5);
          vec2 dir = uv - center;
          float dist = length(dir);
          float falloff = pow(dist, uChromaFalloff + 1.0);
          vec2 offset = dir * uChromaOffset * falloff;
          
          color.r = texture2D(tDiffuse, uv + offset).r;
          color.g = texture2D(tDiffuse, uv).g;
          color.b = texture2D(tDiffuse, uv - offset).b;
          color.a = texture2D(tDiffuse, uv).a;
        } else if (!uGlitchEnabled) {
          color = texture2D(tDiffuse, uv);
        }
        
        // ===== GOD RAYS =====
        if (uGodraysEnabled && uGodraysIntensity > 0.0) {
          vec2 deltaUV = (uv - uLightPos) / float(int(uGodraysSamples));
          float illuminationDecay = 1.0;
          vec3 godrayColor = vec3(0.0);
          vec2 sampleUV = uv;
          
          for (int i = 0; i < 100; i++) {
            if (i >= int(uGodraysSamples)) break;
            sampleUV -= deltaUV;
            vec3 samp = texture2D(tDiffuse, sampleUV).rgb;
            float brightness = dot(samp, vec3(0.299, 0.587, 0.114));
            samp *= illuminationDecay * brightness;
            godrayColor += samp;
            illuminationDecay *= uGodraysDecay;
          }
          
          color.rgb += godrayColor * uGodraysIntensity * 0.02;
        }
        
        // ===== FILM GRAIN =====
        if (uGrain > 0.0) {
          float grainNoise = random(vUv + fract(uTime)) * 2.0 - 1.0;
          color.rgb += grainNoise * uGrain;
        }
        
        // ===== SCANLINES =====
        if (uScanlines > 0.0) {
          float scanline = sin(vUv.y * uResolution.y * 2.0) * 0.5 + 0.5;
          color.rgb *= 1.0 - uScanlines * 0.3 * scanline;
        }
        
        // ===== VIGNETTE =====
        if (uVignette > 0.0) {
          vec2 vigUv = vUv * (1.0 - vUv.yx);
          float vig = vigUv.x * vigUv.y * 15.0;
          vig = pow(vig, uVignette * 0.5);
          color.rgb *= vig;
        }
        
        gl_FragColor = color;
      }
    `
  };

  const apiKey = ""; // Add your Imagen API key

  // ===== STATE MANAGEMENT =====
  const state = {
    title: "GENERATIVE",
    meta: "FIG 01. — 2025",
    desc: "Neural cellular automata exploring self-organizing patterns in digital space.",
    sig: "MonKnight",
    style: "swiss",
    orientation: "portrait"
  };

  // ===== EXPANDED WORD BANKS =====
  const WORD_BANKS = {
    titles: [
      // Technical
      "ENTROPY", "SYSTEM", "NEURAL", "KERNEL", "VECTOR", "MATRIX", "SIGNAL", "FLUX",
      "SYNTH", "GRID", "PULSE", "WAVE", "FIELD", "NODE", "MESH", "ARRAY",
      // Abstract
      "VOID", "ECHO", "DRIFT", "SURGE", "PRISM", "ORBIT", "PHASE", "DECAY",
      // Evocative
      "BLOOM", "EMBER", "FROST", "SHADOW", "STORM", "CRYSTAL", "MIRAGE", "NEXUS",
      // Modern
      "GLITCH", "CYBER", "NEON", "CHROME", "STATIC", "PIXEL", "RENDER", "MORPH"
    ],
    modifiers: [
      "ALPHA", "BETA", "PRIME", "NULL", "ZERO", "OMEGA", "DELTA", "NOVA", "ULTRA", "META"
    ],
    metas: [
      "ITERATION 001", "PROTOTYPE Δ", "SECTOR 7G", "VERSION 2.0", "PHASE III",
      "SEQUENCE 42", "GRID SYSTEM", "AUTO-REGRESSIVE", "LATENT SPACE", "GENERATION X",
      "SPECIMEN A", "MODEL 9", "VARIANT K", "SERIES M", "EDITION ZERO"
    ],
    descs: [
      "Exploring the boundaries of self-organizing systems through computational emergence.",
      "A digital hallucination of organic growth patterns rendered in silicon dreams.",
      "Computed reality through localized interaction rules and cellular automata.",
      "Emergent behavior from simple initial conditions reaching complexity.",
      "Visualizing the unseen data streams of the simulation layer.",
      "Feedback loops creating infinite texture variations across digital manifolds.",
      "Neural pathways mapped onto geometric substrates in latent space.",
      "The intersection of chaos and order in procedural generation.",
      "Algorithmic aesthetics derived from mathematical beauty.",
      "Synthetic nature grown from pure computation.",
      "Digital artifacts from the edge of possibility space.",
      "Where mathematics becomes visible, patterns emerge."
    ]
  };

  // ===== PRESETS =====
  const PRESETS = {
    techno: {
      style: 'tech',
      titles: ['FREQUENCY', 'BASSLINE', 'TECHNO', 'RAVE', 'UNDERGROUND'],
      metas: ['140 BPM', 'WAREHOUSE EDITION', 'LATE NIGHT SESSION'],
      colormap: 'ice',
      bloom: 0.9
    },
    gallery: {
      style: 'art',
      titles: ['UNTITLED', 'COMPOSITION', 'STUDY', 'FRAGMENT', 'OBSERVATION'],
      metas: ['Oil on Canvas', 'Mixed Media', 'Digital Print'],
      colormap: 'mono',
      bloom: 0.3
    },
    poster: {
      style: 'swiss',
      titles: ['FESTIVAL', 'EXHIBITION', 'CONFERENCE', 'SYMPOSIUM'],
      metas: ['MARCH 2025', 'BERLIN', 'TOKYO EDITION'],
      colormap: 'original',
      bloom: 0.5
    },
    album: {
      style: 'brutal',
      titles: ['AFTERMATH', 'ECHOES', 'DESCENT', 'HORIZONS'],
      metas: ['LP OUT NOW', 'STREAMING EVERYWHERE'],
      colormap: 'fire',
      bloom: 1.2
    },
    film: {
      style: 'editorial',
      titles: ['PARALLAX', 'MERIDIAN', 'THRESHOLD', 'CONTINUUM'],
      metas: ['A FILM BY', 'COMING SOON'],
      colormap: 'plasma',
      bloom: 0.7
    },
    brand: {
      style: 'minimal',
      titles: ['STUDIO', 'COLLECTIVE', 'WORKS', 'LAB'],
      metas: ['EST. 2025', 'DESIGN & TECHNOLOGY'],
      colormap: 'mono',
      bloom: 0.4
    }
  };

  // ===== UTILITY FUNCTIONS =====
  function pick(arr) {
    return arr[Math.floor(Math.random() * arr.length)];
  }

  function remixText() {
    const base = pick(WORD_BANKS.titles);
    const addModifier = Math.random() > 0.6;
    state.title = addModifier ? `${base} ${pick(WORD_BANKS.modifiers)}` : base;
    state.meta = `${pick(WORD_BANKS.metas)} — 2025`;
    state.desc = pick(WORD_BANKS.descs);
    updateUIFromState();
  }

  function applyPreset(presetName) {
    const preset = PRESETS[presetName];
    if (!preset) return;
    
    state.style = preset.style;
    state.title = pick(preset.titles);
    state.meta = pick(preset.metas) + ' — 2025';
    
    const styleEl = document.getElementById('p-style');
    const colormapEl = document.getElementById('colormap');
    const bloomEl = document.getElementById('bloomStrength');
    
    if (styleEl) styleEl.value = preset.style;
    if (colormapEl) colormapEl.value = preset.colormap;
    if (bloomEl) bloomEl.value = preset.bloom;
    bloomPass.strength = preset.bloom;
    
    updateUIFromState();
  }

  function updateUIFromState() {
    const titleEl = document.getElementById('t-title');
    const metaEl = document.getElementById('t-meta');
    const descEl = document.getElementById('t-desc');
    const sigEl = document.getElementById('t-sig');
    
    if (titleEl) titleEl.value = state.title;
    if (metaEl) metaEl.value = state.meta;
    if (descEl) descEl.value = state.desc;
    if (sigEl) sigEl.value = state.sig;
    updatePreview();
  }

  function updatePreview() {
    const tTitle = document.getElementById('t-title');
    const tMeta = document.getElementById('t-meta');
    const tDesc = document.getElementById('t-desc');
    const tSig = document.getElementById('t-sig');
    
    if (tTitle) state.title = tTitle.value;
    if (tMeta) state.meta = tMeta.value;
    if (tDesc) state.desc = tDesc.value;
    if (tSig) state.sig = tSig.value;
    
    const dTitle = document.getElementById('d-title');
    const dMeta = document.getElementById('d-meta');
    const dDesc = document.getElementById('d-desc');
    const dSig = document.getElementById('d-sig');
    const dId = document.getElementById('d-id');
    
    if (dTitle) dTitle.textContent = state.title;
    if (dMeta) dMeta.textContent = state.meta;
    if (dDesc) dDesc.textContent = state.desc;
    if (dSig) dSig.textContent = state.sig;
    
    // Generate unique ID
    const hash = (state.title + state.meta).split('').reduce((a, b) => ((a << 5) - a) + b.charCodeAt(0), 0);
    if (dId) dId.textContent = `:: ID ${Math.abs(hash).toString(16).toUpperCase().slice(0, 6)}`;

    // Style class switching
    const layer = document.getElementById('typo-layer');
    if (layer) {
      layer.className = '';
      layer.classList.add(`style-${state.style}`);
    }

    // Orientation
    const cont = document.getElementById('poster-container');
    if (cont) {
      cont.className = '';
      if (state.orientation !== 'portrait') cont.classList.add(state.orientation);
    }
    
    requestAnimationFrame(resizeGeo);
  }

  // ===== EVENT LISTENERS =====
  document.getElementById('btn-remix')?.addEventListener('click', remixText);
  document.getElementById('p-style')?.addEventListener('change', (e) => { state.style = e.target.value; updatePreview(); });
  document.getElementById('p-orient')?.addEventListener('change', (e) => { state.orientation = e.target.value; updatePreview(); });
  
  ['t-title', 't-meta', 't-desc', 't-sig'].forEach(id => {
    document.getElementById(id)?.addEventListener('input', updatePreview);
  });

  // Tab Switching
  document.querySelectorAll('.tab').forEach(b => {
    b.onclick = (e) => {
      document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
      document.querySelectorAll('#ui-right .group').forEach(g => g.classList.add('hidden'));
      e.target.classList.add('active');
      document.getElementById(e.target.dataset.target).classList.remove('hidden');
    };
  });

  // Section Collapse
  document.querySelectorAll('.section-header').forEach(h => {
    h.onclick = () => h.parentElement.classList.toggle('collapsed');
  });

  // Presets
  document.querySelectorAll('.preset-btn').forEach(btn => {
    btn.onclick = () => applyPreset(btn.dataset.preset);
  });

  // Keyboard Shortcuts
  document.addEventListener('keydown', (e) => {
    if (e.target.tagName === 'INPUT') return;
    if (e.key === 'r' || e.key === 'R') remixText();
    if (e.key === 's' || e.key === 'S') document.getElementById('btn-export')?.click();
    if (e.key === ' ') {
      e.preventDefault();
      const cb = document.getElementById('pause');
      if (cb) cb.checked = !cb.checked;
    }
    // Panel toggle shortcuts
    if (e.key === '1') togglePanel('ui-left');
    if (e.key === '2') togglePanel('ui-right');
    if (e.key === 'Escape') {
      // Minimize all panels
      document.querySelectorAll('.panel').forEach(p => p.classList.add('minimized'));
    }
  });

  // ===== PANEL MINIMIZE/MAXIMIZE =====
  function togglePanel(panelId) {
    const panel = document.getElementById(panelId);
    if (panel) {
      panel.classList.toggle('minimized');
    }
  }

  // Setup minimize buttons
  document.querySelectorAll('.minimize-btn').forEach(btn => {
    btn.onclick = (e) => {
      e.stopPropagation();
      const panel = btn.closest('.panel');
      panel.classList.add('minimized');
    };
  });

  // Setup panel icons (click to expand)
  document.querySelectorAll('.panel-icon').forEach(icon => {
    icon.onclick = (e) => {
      e.stopPropagation();
      const panel = icon.closest('.panel');
      panel.classList.remove('minimized');
    };
  });

  // Click on minimized panel to expand
  document.querySelectorAll('.panel').forEach(panel => {
    panel.addEventListener('click', (e) => {
      if (panel.classList.contains('minimized')) {
        panel.classList.remove('minimized');
      }
    });
  });

  // ===== NCA ENGINE (WebGL2) =====
  const ncaCanvas = document.getElementById('gl');
  const gl = ncaCanvas.getContext('webgl2', { preserveDrawingBuffer: true, premultipliedAlpha: false });
  if (!gl) alert("WebGL2 required for NCA simulation");
  gl.getExtension('EXT_color_buffer_float');

  // Shaders
  const VS = `#version 300 es
precision highp float;
const vec2 Q[6] = vec2[6](vec2(-1,-1), vec2(1,-1), vec2(-1,1), vec2(-1,1), vec2(1,-1), vec2(1,1));
out vec2 vUv;
void main() {
  vec2 p = Q[gl_VertexID];
  vUv = p * 0.5 + 0.5;
  gl_Position = vec4(p, 0, 1);
}`;

  const FS_NCA = `#version 300 es
precision highp float;
in vec2 vUv;
out vec4 fragColor;
uniform sampler2D uState;
uniform sampler2D uTarget;
uniform vec2 uTexel;
uniform float uT;
uniform int uMode;
uniform float uStep;
uniform float uNoiseAmp;
uniform float uAttr;
uniform int uPreset;

float hash(vec2 p) { return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453123); }

const float K[9] = float[9](0.05, 0.2, 0.05, 0.2, -1.0, 0.2, 0.05, 0.2, 0.05);

vec4 tap(vec2 uv, vec2 o) { return texture(uState, uv + o * uTexel); }

vec4 neighborhood(vec2 uv) {
  vec2 offs[9] = vec2[9](
    vec2(-1,-1), vec2(0,-1), vec2(1,-1),
    vec2(-1, 0), vec2(0, 0), vec2(1, 0),
    vec2(-1, 1), vec2(0, 1), vec2(1, 1)
  );
  vec4 acc = vec4(0.0);
  for (int j = 0; j < 9; j++) {
    acc += tap(uv, offs[j]) * K[j];
  }
  return acc;
}

float gcurve(float x, float m, float s) {
  x = (x - m) / max(1e-3, s);
  return exp(-0.5 * x * x);
}

void main() {
  vec4 s = texture(uState, vUv);
  vec4 n = neighborhood(vUv);
  float nz = hash(vUv * vec2(391.7, 157.3) + vec2(uT)) * 2.0 - 1.0;
  float v = s.r;
  vec3 hid = s.gba;
  
  if (uPreset == 0) {
    vec4 h = tanh(n + s * 0.5);
    float growth = h.r + 0.25 * h.g - 0.15 * h.b + 0.06 * sin(uT * 0.7);
    v = clamp(v + uStep * (growth + uNoiseAmp * nz), 0.0, 1.0);
  } else {
    float m = 0.5 + 0.1 * sin(uT * 0.7);
    float sgm = 0.12;
    float kresp = gcurve(v + n.r * 0.3, m, sgm) - 0.5;
    v = clamp(v + uStep * (kresp + 0.6 * uNoiseAmp * nz), 0.0, 1.0);
    hid = mix(hid, vec3(v, hid.g, hid.b), 0.05);
  }
  
  if (uMode == 1) {
    float target = texture(uTarget, vUv).r;
    float err = target - v;
    v += uAttr * err;
  }
  
  fragColor = vec4(v, hid);
}`;

  const FS_DISPLAY = `#version 300 es
precision highp float;
in vec2 vUv;
out vec4 fragColor;
uniform sampler2D uState;
uniform sampler2D uOriginal;
uniform int uColorMap;

vec3 ice(float t) {
  return mix(vec3(0.04, 0.08, 0.16), vec3(0.5, 0.85, 1.0), smoothstep(0.0, 1.0, t));
}

vec3 fire(float t) {
  t = clamp(t, 0.0, 1.0);
  vec3 c1 = vec3(0.0);
  vec3 c2 = vec3(0.5, 0.0, 0.0);
  vec3 c3 = vec3(1.0, 0.4, 0.0);
  vec3 c4 = vec3(1.0, 1.0, 0.6);
  return mix(c1, mix(c2, mix(c3, c4, smoothstep(0.6, 1.0, t)), smoothstep(0.2, 0.6, t)), t);
}

vec3 plasma(float t) {
  return vec3(
    0.5 + 0.5 * sin(6.283 * t + 0.0),
    0.5 + 0.5 * sin(6.283 * t + 2.1),
    0.5 + 0.5 * sin(6.283 * t + 4.2)
  );
}

vec3 viridis(float t) {
  vec3 c0 = vec3(0.267, 0.004, 0.329);
  vec3 c1 = vec3(0.282, 0.140, 0.457);
  vec3 c2 = vec3(0.253, 0.265, 0.529);
  vec3 c3 = vec3(0.191, 0.407, 0.556);
  vec3 c4 = vec3(0.127, 0.566, 0.550);
  vec3 c5 = vec3(0.267, 0.678, 0.480);
  vec3 c6 = vec3(0.478, 0.821, 0.318);
  vec3 c7 = vec3(0.993, 0.906, 0.144);
  
  if (t < 0.143) return mix(c0, c1, t / 0.143);
  if (t < 0.286) return mix(c1, c2, (t - 0.143) / 0.143);
  if (t < 0.429) return mix(c2, c3, (t - 0.286) / 0.143);
  if (t < 0.571) return mix(c3, c4, (t - 0.429) / 0.143);
  if (t < 0.714) return mix(c4, c5, (t - 0.571) / 0.143);
  if (t < 0.857) return mix(c5, c6, (t - 0.714) / 0.143);
  return mix(c6, c7, (t - 0.857) / 0.143);
}

vec3 magma(float t) {
  vec3 c0 = vec3(0.001, 0.0, 0.014);
  vec3 c1 = vec3(0.281, 0.099, 0.416);
  vec3 c2 = vec3(0.596, 0.171, 0.402);
  vec3 c3 = vec3(0.922, 0.377, 0.271);
  vec3 c4 = vec3(0.996, 0.812, 0.565);
  
  if (t < 0.25) return mix(c0, c1, t / 0.25);
  if (t < 0.5) return mix(c1, c2, (t - 0.25) / 0.25);
  if (t < 0.75) return mix(c2, c3, (t - 0.5) / 0.25);
  return mix(c3, c4, (t - 0.75) / 0.25);
}

void main() {
  float v = texture(uState, vUv).r;
  float t = pow(v, 1.5);
  vec3 col;
  
  if (uColorMap == 0) col = ice(t);
  else if (uColorMap == 1) col = fire(t);
  else if (uColorMap == 2) col = plasma(t);
  else if (uColorMap == 3) col = viridis(t);
  else if (uColorMap == 4) col = magma(t);
  else if (uColorMap == 5) col = vec3(t);
  else {
    vec3 tex = texture(uOriginal, vUv).rgb;
    col = tex * smoothstep(0.02, 0.98, t);
  }
  
  fragColor = vec4(col, 1.0);
}`;

  function createProgram(vs, fs) {
    const s1 = gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(s1, vs);
    gl.compileShader(s1);
    
    const s2 = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(s2, fs);
    gl.compileShader(s2);
    
    const p = gl.createProgram();
    gl.attachShader(p, s1);
    gl.attachShader(p, s2);
    gl.linkProgram(p);
    return p;
  }

  const progNCA = createProgram(VS, FS_NCA);
  const progDISP = createProgram(VS, FS_DISPLAY);

  // Textures
  const W = 512, H = 512;
  const targetTex = gl.createTexture();
  const originalTex = gl.createTexture();
  const stateA = gl.createTexture();
  const stateB = gl.createTexture();

  [targetTex, originalTex].forEach(t => {
    gl.bindTexture(gl.TEXTURE_2D, t);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA8, W, H, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
  });

  [stateA, stateB].forEach(t => {
    gl.bindTexture(gl.TEXTURE_2D, t);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA8, W, H, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
  });

  const fboA = gl.createFramebuffer();
  gl.bindFramebuffer(gl.FRAMEBUFFER, fboA);
  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, stateA, 0);

  const fboB = gl.createFramebuffer();
  gl.bindFramebuffer(gl.FRAMEBUFFER, fboB);
  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, stateB, 0);

  let ping = { tex: stateA, fbo: fboA };
  let pong = { tex: stateB, fbo: fboB };

  // Helper canvas
  const hCan = document.createElement('canvas');
  hCan.width = W;
  hCan.height = H;
  const hCtx = hCan.getContext('2d');

  function uploadTarget(img) {
    hCtx.drawImage(img, 0, 0, W, H);
    const id = hCtx.getImageData(0, 0, W, H);
    
    gl.bindTexture(gl.TEXTURE_2D, originalTex);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA8, W, H, 0, gl.RGBA, gl.UNSIGNED_BYTE, id);
    
    const gray = new Uint8Array(W * H * 4);
    for (let i = 0; i < id.data.length; i += 4) {
      const l = (id.data[i] * 0.299 + id.data[i+1] * 0.587 + id.data[i+2] * 0.114) | 0;
      gray[i] = l;
      gray[i+1] = l;
      gray[i+2] = l;
      gray[i+3] = 255;
    }
    gl.bindTexture(gl.TEXTURE_2D, targetTex);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA8, W, H, 0, gl.RGBA, gl.UNSIGNED_BYTE, gray);
  }

  function seedPattern(pattern = 'random') {
    const buf = new Uint8Array(W * H * 4);
    
    for (let y = 0; y < H; y++) {
      for (let x = 0; x < W; x++) {
        const i = (y * W + x) * 4;
        let v = 0;
        
        switch (pattern) {
          case 'random':
            v = Math.random() * 255;
            break;
          case 'disk':
            const dx = x - W/2, dy = y - H/2;
            v = Math.sqrt(dx*dx + dy*dy) < W/4 ? 255 : 0;
            break;
          case 'rings':
            const dist = Math.sqrt((x - W/2)**2 + (y - H/2)**2);
            v = Math.sin(dist * 0.1) * 127 + 128;
            break;
          case 'gradient':
            v = (x / W) * 255;
            break;
          case 'checkerboard':
            v = ((Math.floor(x / 32) + Math.floor(y / 32)) % 2) * 255;
            break;
          case 'noise':
            // Simple noise approximation
            v = (Math.sin(x * 0.1) * Math.cos(y * 0.1) + 1) * 127;
            break;
        }
        
        buf[i] = v;
        buf[i+1] = Math.random() * 128;
        buf[i+2] = Math.random() * 128;
        buf[i+3] = 255;
      }
    }
    
    gl.bindTexture(gl.TEXTURE_2D, ping.tex);
    gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, W, H, gl.RGBA, gl.UNSIGNED_BYTE, buf);
  }

  seedPattern('random');

  // ===== THREE.JS SCENE =====
  const geoCanvas = document.getElementById('geo');
  const renderer = new THREE.WebGLRenderer({
    canvas: geoCanvas,
    antialias: true,
    alpha: true,
    preserveDrawingBuffer: true
  });
  renderer.outputColorSpace = THREE.SRGBColorSpace;

  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(45, 1, 0.1, 100);
  camera.position.set(2.8, 2.0, 3.2);

  const controls = new OrbitControls(camera, geoCanvas);
  controls.enableDamping = true;
  controls.dampingFactor = 0.05;

  // Post-processing with alpha support
  const renderTarget = new THREE.WebGLRenderTarget(512, 512, {
    format: THREE.RGBAFormat,
    stencilBuffer: false,
    type: THREE.HalfFloatType,
    colorSpace: THREE.SRGBColorSpace
  });
  const composer = new EffectComposer(renderer, renderTarget);
  const renderPass = new RenderPass(scene, camera);
  renderPass.clear = true;
  renderPass.clearDepth = true;
  const bloomPass = new UnrealBloomPass(new THREE.Vector2(512, 512), 0.65, 0.5, 0.15);
  const effectsPass = new ShaderPass(CustomEffectsShader);
  const outputPass = new OutputPass();

  composer.addPass(renderPass);
  composer.addPass(bloomPass);
  composer.addPass(effectsPass);
  composer.addPass(outputPass);
  
  // Renderer configuration (updated by renderBackground())
  renderer.setClearColor(0x0a0a0f, 1);
  renderer.autoClear = false; // Manual clearing for alpha control

  // Texture
  const maxAniso = renderer.capabilities.getMaxAnisotropy();
  const ncaTex = new THREE.CanvasTexture(ncaCanvas);
  ncaTex.minFilter = THREE.LinearMipmapLinearFilter;
  ncaTex.magFilter = THREE.LinearFilter;
  ncaTex.generateMipmaps = true;
  ncaTex.anisotropy = maxAniso;
  ncaTex.wrapS = THREE.RepeatWrapping;
  ncaTex.wrapT = THREE.RepeatWrapping;

  // Material
  const mat = new THREE.MeshStandardMaterial({
    color: 0x111214,
    map: ncaTex,
    metalness: 0.15,
    roughness: 0.45,
    normalMap: ncaTex,
    normalScale: new THREE.Vector2(0.4, 0.4)
  });

  // Geometries collection
  const GEOMETRIES = {
    'torus': () => new THREE.TorusKnotGeometry(1, 0.3, 128, 64),
    'sphere': () => new THREE.SphereGeometry(1.2, 64, 64),
    'box': () => new THREE.BoxGeometry(1.6, 1.6, 1.6, 8, 8, 8),
    'icosa': () => new THREE.IcosahedronGeometry(1.4, 2),
    'octa': () => new THREE.OctahedronGeometry(1.4, 2),
    'dodeca': () => new THREE.DodecahedronGeometry(1.3, 1),
    'torus-simple': () => new THREE.TorusGeometry(1.1, 0.4, 32, 64),
    'cylinder': () => new THREE.CylinderGeometry(0.8, 0.8, 2, 32, 8),
    'cone': () => new THREE.ConeGeometry(1, 2, 32, 8),
    'ring': () => new THREE.RingGeometry(0.6, 1.4, 32),
    'capsule': () => new THREE.CapsuleGeometry(0.6, 1.4, 8, 32),
    'plane': () => new THREE.PlaneGeometry(2.8, 2.8, 32, 32),
    'klein': () => {
      // Klein bottle parametric
      function klein(u, v, target) {
        u *= Math.PI;
        v *= 2 * Math.PI;
        u = u * 2;
        
        let x, y, z;
        if (u < Math.PI) {
          x = 3 * Math.cos(u) * (1 + Math.sin(u)) + (2 * (1 - Math.cos(u) / 2)) * Math.cos(u) * Math.cos(v);
          z = -8 * Math.sin(u) - 2 * (1 - Math.cos(u) / 2) * Math.sin(u) * Math.cos(v);
        } else {
          x = 3 * Math.cos(u) * (1 + Math.sin(u)) + (2 * (1 - Math.cos(u) / 2)) * Math.cos(v + Math.PI);
          z = -8 * Math.sin(u);
        }
        y = -2 * (1 - Math.cos(u) / 2) * Math.sin(v);
        
        target.set(x * 0.15, y * 0.15, z * 0.15);
      }
      return new ParametricGeometry(klein, 32, 32);
    },
    'mobius': () => {
      function mobius(u, t, target) {
        u = u - 0.5;
        const v = 2 * Math.PI * t;
        const a = 2;
        
        const x = Math.cos(v) * (a + u * Math.cos(v / 2));
        const y = Math.sin(v) * (a + u * Math.cos(v / 2));
        const z = u * Math.sin(v / 2);
        
        target.set(x * 0.6, y * 0.6, z * 0.6);
      }
      return new ParametricGeometry(mobius, 32, 64);
    }
  };

  let mesh = new THREE.Mesh(GEOMETRIES['torus'](), mat);
  scene.add(mesh);

  // Lights
  const hemiLight = new THREE.HemisphereLight(0xffffff, 0x080808, 1.0);
  scene.add(hemiLight);

  const keyLight = new THREE.DirectionalLight(0xffffff, 1.8);
  keyLight.position.set(4, 5, 3);
  scene.add(keyLight);

  const fillLight = new THREE.DirectionalLight(0x8888ff, 0.4);
  fillLight.position.set(-3, 2, -2);
  scene.add(fillLight);

  const rimLight = new THREE.DirectionalLight(0xff8866, 0.3);
  rimLight.position.set(0, -2, -4);
  scene.add(rimLight);

  // Sensors
  const sensorGroup = new THREE.Group();
  mesh.add(sensorGroup);

  function rebuildSensors() {
    while (sensorGroup.children.length) sensorGroup.remove(sensorGroup.children[0]);
    const g = new THREE.SphereGeometry(0.04);
    for (let i = 0; i < 16; i++) {
      const m = new THREE.Mesh(g, new THREE.MeshStandardMaterial({
        color: 0x000000,
        emissive: new THREE.Color().setHSL(i / 16, 0.8, 0.5)
      }));
      const pt = new THREE.Vector3(
        Math.random() - 0.5,
        Math.random() - 0.5,
        Math.random() - 0.5
      ).normalize().multiplyScalar(1.3);
      m.position.copy(pt);
      sensorGroup.add(m);
    }
    // Initialize physics for new sensors
    if (typeof initSensorPhysics === 'function') {
      setTimeout(initSensorPhysics, 10);
    }
  }
  rebuildSensors();

  function updateSensors(t) {
    const cb = document.getElementById('showSensors');
    if (!cb || !cb.checked) {
      sensorGroup.visible = false;
      return;
    }
    sensorGroup.visible = true;
    sensorGroup.children.forEach((c, i) => {
      const s = 0.4 + 0.4 * Math.sin(t * 2.5 + i * 0.5);
      c.scale.setScalar(s);
      c.material.emissiveIntensity = s * 2.5;
    });
  }

  // ===== PHYSICS SYSTEM =====
  const physicsState = {
    enabled: false,
    gravity: 0,
    viscosity: 0.2,
    attraction: 0.5,
    repulsion: 0.3,
    turbulence: 0.5,
    turbSpeed: 1.0
  };

  // ===== PARTICLE SYSTEM =====
  const MAX_PARTICLES = 50000;
  const particleState = {
    enabled: false,
    count: 5000,
    size: 0.5,
    shape: 'circle',
    constraintType: 'sphere',
    constraintScale: 2.0,
    speed: 0.5,
    primaryColor: new THREE.Color(0x7dd3fc),
    secondaryColor: new THREE.Color(0xa78bfa),
    focalLength: 50,
    aperture: 2.8,
    focusDistance: 5.0,
    bloomIntensity: 0.8,
    time: 0
  };
  
  // Particle physics arrays
  const particleVelocities = new Float32Array(MAX_PARTICLES * 3);
  const particleAges = new Float32Array(MAX_PARTICLES);
  const particleLifespans = new Float32Array(MAX_PARTICLES);
  
  // Create particle geometry
  const particlePositions = new Float32Array(MAX_PARTICLES * 3);
  const particleData = new Float32Array(MAX_PARTICLES * 2); // phase, speed variation
  
  function initializeParticlePosition(index) {
    const i3 = index * 3;
    const scale = particleState.constraintScale;
    
    switch(particleState.constraintType) {
      case 'sphere':
        const r = scale * Math.cbrt(Math.random());
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        particlePositions[i3] = r * Math.sin(phi) * Math.cos(theta);
        particlePositions[i3 + 1] = r * Math.sin(phi) * Math.sin(theta);
        particlePositions[i3 + 2] = r * Math.cos(phi);
        break;
      case 'box':
        particlePositions[i3] = (Math.random() - 0.5) * scale * 2;
        particlePositions[i3 + 1] = (Math.random() - 0.5) * scale * 2;
        particlePositions[i3 + 2] = (Math.random() - 0.5) * scale * 2;
        break;
      case 'torus':
        const torusR = scale * 0.8;
        const torusr = scale * 0.3;
        const u = Math.random() * Math.PI * 2;
        const v = Math.random() * Math.PI * 2;
        particlePositions[i3] = (torusR + torusr * Math.cos(v)) * Math.cos(u);
        particlePositions[i3 + 1] = (torusR + torusr * Math.cos(v)) * Math.sin(u);
        particlePositions[i3 + 2] = torusr * Math.sin(v);
        break;
      case 'plane':
        particlePositions[i3] = (Math.random() - 0.5) * scale * 4;
        particlePositions[i3 + 1] = (Math.random() - 0.5) * 0.2;
        particlePositions[i3 + 2] = (Math.random() - 0.5) * scale * 4;
        break;
      case 'cylinder':
        const cylAngle = Math.random() * Math.PI * 2;
        const cylRadius = scale * 0.5 * Math.sqrt(Math.random());
        const cylHeight = (Math.random() - 0.5) * scale * 2;
        particlePositions[i3] = cylRadius * Math.cos(cylAngle);
        particlePositions[i3 + 1] = cylHeight;
        particlePositions[i3 + 2] = cylRadius * Math.sin(cylAngle);
        break;
      case 'cone':
        const coneT = Math.random();
        const coneAngle = Math.random() * Math.PI * 2;
        const coneRadius = scale * 0.5 * coneT * Math.sqrt(Math.random());
        const coneHeight = coneT * scale - scale * 0.5;
        particlePositions[i3] = coneRadius * Math.cos(coneAngle);
        particlePositions[i3 + 1] = coneHeight;
        particlePositions[i3 + 2] = coneRadius * Math.sin(coneAngle);
        break;
      case 'spiral':
        const spiralT = Math.random() * 4 * Math.PI;
        const spiralR = scale * 0.1 + spiralT * scale * 0.1;
        const spiralJitter = (Math.random() - 0.5) * 0.3;
        particlePositions[i3] = (spiralR + spiralJitter) * Math.cos(spiralT);
        particlePositions[i3 + 1] = (spiralT / (4 * Math.PI) - 0.5) * scale * 2;
        particlePositions[i3 + 2] = (spiralR + spiralJitter) * Math.sin(spiralT);
        break;
      default:
        const rDef = scale * Math.cbrt(Math.random());
        const thetaDef = Math.random() * Math.PI * 2;
        const phiDef = Math.acos(2 * Math.random() - 1);
        particlePositions[i3] = rDef * Math.sin(phiDef) * Math.cos(thetaDef);
        particlePositions[i3 + 1] = rDef * Math.sin(phiDef) * Math.sin(thetaDef);
        particlePositions[i3 + 2] = rDef * Math.cos(phiDef);
    }
    
    // Random velocity scaled by speed setting
    const speedMult = particleState.speed || 0.5;
    particleVelocities[i3] = (Math.random() - 0.5) * 0.05 * speedMult;
    particleVelocities[i3 + 1] = (Math.random() - 0.5) * 0.05 * speedMult;
    particleVelocities[i3 + 2] = (Math.random() - 0.5) * 0.05 * speedMult;
    
    // Random age and lifespan
    particleAges[index] = Math.random() * 10;
    particleLifespans[index] = 5 + Math.random() * 10;
  }
  
  // Initialize all particles
  for (let i = 0; i < MAX_PARTICLES; i++) {
    initializeParticlePosition(i);
    particleData[i * 2] = Math.random() * 100;
    particleData[i * 2 + 1] = 0.5 + Math.random() * 0.5;
  }
  
  const particleGeometry = new THREE.BufferGeometry();
  particleGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
  particleGeometry.setAttribute('data', new THREE.BufferAttribute(particleData, 2));
  particleGeometry.setDrawRange(0, particleState.count);
  
  // Particle shader material with optical effects and shape support
  const particleMaterial = new THREE.ShaderMaterial({
    uniforms: {
      uTime: { value: 0 },
      uSize: { value: particleState.size },
      uShape: { value: 1 }, // 0=point, 1=circle, 2=ring, 3=square, 4=diamond, 5=star, 6=heart, 7=cross
      uPrimaryColor: { value: particleState.primaryColor },
      uSecondaryColor: { value: particleState.secondaryColor },
      uFocalLength: { value: particleState.focalLength },
      uAperture: { value: particleState.aperture },
      uFocusDistance: { value: particleState.focusDistance },
      uBloomIntensity: { value: particleState.bloomIntensity }
    },
    vertexShader: `
      uniform float uTime;
      uniform float uSize;
      uniform float uFocalLength;
      uniform float uAperture;
      uniform float uFocusDistance;
      uniform vec3 uPrimaryColor;
      uniform vec3 uSecondaryColor;
      attribute vec2 data;
      varying float vAlpha;
      varying float vCoc;
      varying vec3 vColor;
      
      void main() {
        vec3 pos = position;
        float phase = data.x;
        float speedVar = data.y;
        
        // Life-based animation
        float life = fract((uTime * 0.1 + phase) * 0.1);
        float ageFactor = smoothstep(0.0, 0.2, life) * (1.0 - smoothstep(0.8, 1.0, life));
        
        // Optical simulation
        vec4 mv = modelViewMatrix * vec4(pos, 1.0);
        float dist = -mv.z;
        
        // Circle of confusion
        float coc = abs(dist - uFocusDistance) / (uFocusDistance * uAperture) * 0.036;
        vCoc = clamp(coc, 0.0, 1.0);
        
        // Point size with optical bokeh effect
        float baseSize = uSize * (1.0 + ageFactor * 0.3);
        gl_PointSize = baseSize * (uFocalLength / max(1.0, dist)) * (1.0 + vCoc * 4.0) * 15.0;
        gl_Position = projectionMatrix * mv;
        
        // Alpha with depth fade
        float distanceFade = 1.0 - smoothstep(30.0, 60.0, dist);
        vAlpha = ageFactor * distanceFade * (0.6 + 0.4 * (1.0 - vCoc));
        
        // Color blend based on position and time
        float colorMix = sin(uTime * 0.2 + pos.x * 2.0 + pos.y + pos.z) * 0.5 + 0.5;
        vColor = mix(uPrimaryColor, uSecondaryColor, colorMix);
      }
    `,
    fragmentShader: `
      uniform float uBloomIntensity;
      uniform float uAperture;
      uniform int uShape;
      varying float vAlpha;
      varying float vCoc;
      varying vec3 vColor;
      
      // Shape distance functions
      float sdCircle(vec2 p) { return length(p) - 0.4; }
      float sdRing(vec2 p) { return abs(length(p) - 0.35) - 0.08; }
      float sdSquare(vec2 p) { vec2 d = abs(p) - 0.35; return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0); }
      float sdDiamond(vec2 p) { p = abs(p); return (p.x + p.y - 0.5) * 0.707; }
      float sdStar(vec2 p) {
        float a = atan(p.y, p.x) + 3.14159;
        float r = length(p);
        float f = cos(a * 2.5) * 0.5 + 0.5;
        return r - 0.35 * (0.6 + 0.4 * f);
      }
      float sdHeart(vec2 p) {
        p.y -= 0.15;
        p.x = abs(p.x);
        if(p.y + p.x > 0.5) return sqrt(dot(p - vec2(0.25, 0.25), p - vec2(0.25, 0.25))) - 0.25;
        return sqrt(min(dot(p - vec2(0.0, 0.5), p - vec2(0.0, 0.5)),
                       dot(p - vec2(0.35, 0.35), p - vec2(0.35, 0.35)))) * sign(p.x - p.y);
      }
      float sdCross(vec2 p) {
        p = abs(p);
        vec2 d = vec2(max(p.x - 0.1, p.y - 0.4), max(p.x - 0.4, p.y - 0.1));
        return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));
      }
      
      void main() {
        vec2 uv = gl_PointCoord - 0.5;
        float d;
        
        // Select shape
        if(uShape == 0) { // Point
          d = length(uv) - 0.15;
        } else if(uShape == 1) { // Circle
          d = sdCircle(uv);
        } else if(uShape == 2) { // Ring
          d = sdRing(uv);
        } else if(uShape == 3) { // Square
          d = sdSquare(uv);
        } else if(uShape == 4) { // Diamond
          d = sdDiamond(uv);
        } else if(uShape == 5) { // Star
          d = sdStar(uv);
        } else if(uShape == 6) { // Heart
          d = sdHeart(uv);
        } else { // Cross
          d = sdCross(uv);
        }
        
        if(d > 0.05) discard;
        
        // Soft edge with bokeh effect
        float edge = smoothstep(0.05, -0.1, d);
        float alpha = vAlpha * (0.6 + 0.4 * edge);
        
        // Depth blur effect
        alpha *= (0.3 + 0.7 * (1.0 - vCoc));
        
        // Bloom glow
        float bloom = pow(edge, 0.5) * uBloomIntensity * (1.0 / uAperture);
        vec3 color = vColor * (1.0 + bloom * 0.6);
        
        // Lens flare for bright particles
        if(uBloomIntensity > 0.4) {
          float flare = pow(1.0 - d, 4.0) * 0.2 * uBloomIntensity;
          color += vec3(1.0, 0.9, 0.7) * flare;
        }
        
        gl_FragColor = vec4(color, alpha);
      }
    `,
    transparent: true,
    depthWrite: false,
    blending: THREE.AdditiveBlending
  });
  
  const particleSystem = new THREE.Points(particleGeometry, particleMaterial);
  particleSystem.visible = false;
  particleSystem.frustumCulled = false;
  scene.add(particleSystem);
  
  // Update particles function
  function updateParticles(dt) {
    if (!particleState.enabled) return;
    
    particleState.time += dt;
    particleMaterial.uniforms.uTime.value = particleState.time;
    
    const count = Math.min(particleState.count, MAX_PARTICLES);
    const scale = particleState.constraintScale;
    
    for (let i = 0; i < count; i++) {
      const i3 = i * 3;
      
      // Apply physics based on sensor physics settings
      if (physicsState.enabled) {
        // Gravity
        particleVelocities[i3 + 1] += physicsState.gravity * 0.002 * dt;
        
        // Viscosity
        particleVelocities[i3] *= (1 - physicsState.viscosity * 0.1);
        particleVelocities[i3 + 1] *= (1 - physicsState.viscosity * 0.1);
        particleVelocities[i3 + 2] *= (1 - physicsState.viscosity * 0.1);
        
        // Turbulence
        const turbTime = particleState.time * physicsState.turbSpeed;
        const tx = Math.sin(particlePositions[i3] * 2 + turbTime) * 0.5;
        const ty = Math.sin(particlePositions[i3 + 1] * 2 + turbTime * 0.7) * 0.5;
        const tz = Math.sin(particlePositions[i3 + 2] * 2 + turbTime * 0.5) * 0.5;
        particleVelocities[i3] += tx * physicsState.turbulence * 0.001;
        particleVelocities[i3 + 1] += ty * physicsState.turbulence * 0.001;
        particleVelocities[i3 + 2] += tz * physicsState.turbulence * 0.001;
      }
      
      // Update positions
      particlePositions[i3] += particleVelocities[i3];
      particlePositions[i3 + 1] += particleVelocities[i3 + 1];
      particlePositions[i3 + 2] += particleVelocities[i3 + 2];
      
      // Apply constraints
      applyParticleConstraint(i);
      
      // Age and rebirth
      particleAges[i] += dt;
      if (particleAges[i] > particleLifespans[i]) {
        initializeParticlePosition(i);
      }
    }
    
    particleGeometry.attributes.position.needsUpdate = true;
  }
  
  function applyParticleConstraint(index) {
    const i3 = index * 3;
    const scale = particleState.constraintScale;
    
    switch(particleState.constraintType) {
      case 'sphere':
        const dist = Math.sqrt(
          particlePositions[i3] ** 2 +
          particlePositions[i3 + 1] ** 2 +
          particlePositions[i3 + 2] ** 2
        );
        if (dist > scale) {
          const ratio = scale / dist;
          particlePositions[i3] *= ratio;
          particlePositions[i3 + 1] *= ratio;
          particlePositions[i3 + 2] *= ratio;
          particleVelocities[i3] *= -0.3;
          particleVelocities[i3 + 1] *= -0.3;
          particleVelocities[i3 + 2] *= -0.3;
        }
        break;
      case 'box':
        const half = scale;
        if (Math.abs(particlePositions[i3]) > half) {
          particlePositions[i3] = Math.sign(particlePositions[i3]) * half;
          particleVelocities[i3] *= -0.3;
        }
        if (Math.abs(particlePositions[i3 + 1]) > half) {
          particlePositions[i3 + 1] = Math.sign(particlePositions[i3 + 1]) * half;
          particleVelocities[i3 + 1] *= -0.3;
        }
        if (Math.abs(particlePositions[i3 + 2]) > half) {
          particlePositions[i3 + 2] = Math.sign(particlePositions[i3 + 2]) * half;
          particleVelocities[i3 + 2] *= -0.3;
        }
        break;
    }
  }
  
  // Particle presets
  const particlePresets = {
    nebula: { count: 15000, size: 0.6, constraint: 'sphere', scale: 3, color1: '#6366f1', color2: '#ec4899', focal: 85, aperture: 1.8, focus: 4, bloom: 1.2 },
    galaxy: { count: 20000, size: 0.4, constraint: 'torus', scale: 2.5, color1: '#8b5cf6', color2: '#06b6d4', focal: 50, aperture: 2.8, focus: 5, bloom: 0.9 },
    sparks: { count: 8000, size: 0.8, constraint: 'sphere', scale: 1.5, color1: '#f97316', color2: '#fbbf24', focal: 35, aperture: 4, focus: 3, bloom: 1.5 },
    dust: { count: 10000, size: 0.3, constraint: 'box', scale: 3, color1: '#d4d4d8', color2: '#a1a1aa', focal: 50, aperture: 5.6, focus: 6, bloom: 0.4 },
    bokeh: { count: 3000, size: 1.5, constraint: 'sphere', scale: 4, color1: '#7dd3fc', color2: '#f0abfc', focal: 135, aperture: 1.4, focus: 3, bloom: 1.8 }
  };

  // Physics data for sensors
  const sensorPhysics = {
    velocities: [],
    forces: [],
    basePositions: []
  };

  function initSensorPhysics() {
    sensorPhysics.velocities = [];
    sensorPhysics.forces = [];
    sensorPhysics.basePositions = [];
    
    sensorGroup.children.forEach((c) => {
      sensorPhysics.velocities.push(new THREE.Vector3(
        (Math.random() - 0.5) * 0.02,
        (Math.random() - 0.5) * 0.02,
        (Math.random() - 0.5) * 0.02
      ));
      sensorPhysics.forces.push(new THREE.Vector3());
      sensorPhysics.basePositions.push(c.position.clone());
    });
  }

  // Simple noise function for turbulence
  function simplexNoise3D(x, y, z) {
    return Math.sin(x * 3.14159 + y * 2.71828 + z * 1.61803) * 0.5;
  }

  function updatePhysics(dt) {
    if (!physicsState.enabled) return;
    
    const time = performance.now() * 0.001;
    const count = sensorGroup.children.length;
    
    for (let i = 0; i < count; i++) {
      const sensor = sensorGroup.children[i];
      const vel = sensorPhysics.velocities[i];
      const force = sensorPhysics.forces[i];
      const basePos = sensorPhysics.basePositions[i];
      
      // Reset forces
      force.set(0, 0, 0);
      
      // Gravity
      force.y += physicsState.gravity * 0.01;
      
      // Viscosity (drag)
      force.x -= vel.x * physicsState.viscosity * 0.5;
      force.y -= vel.y * physicsState.viscosity * 0.5;
      force.z -= vel.z * physicsState.viscosity * 0.5;
      
      // Turbulence
      const turbScale = 0.5;
      const turbTime = time * physicsState.turbSpeed;
      const tx = simplexNoise3D(sensor.position.x * turbScale + turbTime, sensor.position.y * turbScale, sensor.position.z * turbScale);
      const ty = simplexNoise3D(sensor.position.x * turbScale, sensor.position.y * turbScale + turbTime, sensor.position.z * turbScale);
      const tz = simplexNoise3D(sensor.position.x * turbScale, sensor.position.y * turbScale, sensor.position.z * turbScale + turbTime);
      force.x += tx * physicsState.turbulence * 0.02;
      force.y += ty * physicsState.turbulence * 0.02;
      force.z += tz * physicsState.turbulence * 0.02;
      
      // Attraction to base position
      const toBase = basePos.clone().sub(sensor.position);
      const distToBase = toBase.length();
      if (distToBase > 0.1) {
        toBase.normalize().multiplyScalar(physicsState.attraction * 0.01);
        force.add(toBase);
      }
      
      // Inter-particle forces
      for (let j = 0; j < count; j++) {
        if (i === j) continue;
        const other = sensorGroup.children[j];
        const diff = sensor.position.clone().sub(other.position);
        const dist = diff.length();
        
        if (dist < 0.05 || dist > 2) continue;
        
        diff.normalize();
        
        // Attraction
        const attractF = physicsState.attraction * 0.0005 / (dist * dist);
        force.sub(diff.clone().multiplyScalar(attractF));
        
        // Repulsion
        const repelF = physicsState.repulsion * 0.002 / (dist * dist);
        force.add(diff.clone().multiplyScalar(repelF));
      }
      
      // Apply forces to velocity
      vel.add(force.multiplyScalar(dt));
      
      // Clamp velocity
      const maxVel = 0.1;
      if (vel.length() > maxVel) {
        vel.normalize().multiplyScalar(maxVel);
      }
      
      // Update position
      sensor.position.add(vel.clone().multiplyScalar(dt * 60));
      
      // Constrain to sphere around mesh
      const distFromCenter = sensor.position.length();
      if (distFromCenter > 2.5) {
        sensor.position.normalize().multiplyScalar(2.5);
        vel.multiplyScalar(-0.3); // Bounce
      }
    }
  }

  // Physics presets
  const physicsPresets = {
    smoke: { gravity: -0.3, viscosity: 0.7, attraction: 0.1, repulsion: 0.05, turbulence: 0.8, turbSpeed: 0.5 },
    fluid: { gravity: -0.1, viscosity: 0.4, attraction: 0.6, repulsion: 0.4, turbulence: 0.3, turbSpeed: 0.8 },
    dust: { gravity: -0.05, viscosity: 0.1, attraction: 0.0, repulsion: 0.0, turbulence: 2.0, turbSpeed: 1.5 },
    fire: { gravity: 0.5, viscosity: 0.3, attraction: 0.2, repulsion: 0.8, turbulence: 1.5, turbSpeed: 2.0 },
    orbit: { gravity: 0.0, viscosity: 0.05, attraction: 1.2, repulsion: 0.2, turbulence: 0.1, turbSpeed: 0.3 }
  };

  // Physics preset handlers
  document.querySelectorAll('[data-phys]').forEach(btn => {
    btn.onclick = () => {
      const preset = physicsPresets[btn.dataset.phys];
      if (!preset) return;
      
      physicsState.gravity = preset.gravity;
      physicsState.viscosity = preset.viscosity;
      physicsState.attraction = preset.attraction;
      physicsState.repulsion = preset.repulsion;
      physicsState.turbulence = preset.turbulence;
      physicsState.turbSpeed = preset.turbSpeed;
      
      // Update UI with null checks
      const gravityEl = document.getElementById('phys-gravity');
      const viscosityEl = document.getElementById('phys-viscosity');
      const attractionEl = document.getElementById('phys-attraction');
      const repulsionEl = document.getElementById('phys-repulsion');
      const turbulenceEl = document.getElementById('phys-turbulence');
      const turbSpeedEl = document.getElementById('phys-turb-speed');
      const physEnabledEl = document.getElementById('physics-enabled');
      
      if (gravityEl) gravityEl.value = preset.gravity;
      if (viscosityEl) viscosityEl.value = preset.viscosity;
      if (attractionEl) attractionEl.value = preset.attraction;
      if (repulsionEl) repulsionEl.value = preset.repulsion;
      if (turbulenceEl) turbulenceEl.value = preset.turbulence;
      if (turbSpeedEl) turbSpeedEl.value = preset.turbSpeed;
      
      // Enable physics if not already
      physicsState.enabled = true;
      if (physEnabledEl) physEnabledEl.checked = true;
      
      // Highlight active preset
      document.querySelectorAll('[data-phys]').forEach(b => b.style.borderColor = '');
      btn.style.borderColor = 'var(--accent)';
    };
  });

  // Physics control handlers
  document.getElementById('physics-enabled')?.addEventListener('change', (e) => {
    physicsState.enabled = e.target.checked;
    if (e.target.checked && sensorPhysics.velocities.length === 0) {
      initSensorPhysics();
    }
  });
  document.getElementById('phys-gravity')?.addEventListener('input', (e) => physicsState.gravity = parseFloat(e.target.value));
  document.getElementById('phys-viscosity')?.addEventListener('input', (e) => physicsState.viscosity = parseFloat(e.target.value));
  document.getElementById('phys-attraction')?.addEventListener('input', (e) => physicsState.attraction = parseFloat(e.target.value));
  document.getElementById('phys-repulsion')?.addEventListener('input', (e) => physicsState.repulsion = parseFloat(e.target.value));
  document.getElementById('phys-turbulence')?.addEventListener('input', (e) => physicsState.turbulence = parseFloat(e.target.value));
  document.getElementById('phys-turb-speed')?.addEventListener('input', (e) => physicsState.turbSpeed = parseFloat(e.target.value));

  // ===== PARTICLE SYSTEM HANDLERS =====
  document.getElementById('particles-enabled')?.addEventListener('change', (e) => {
    particleState.enabled = e.target.checked;
    particleSystem.visible = e.target.checked;
  });
  
  document.getElementById('particle-count')?.addEventListener('input', (e) => {
    const count = parseInt(e.target.value);
    particleState.count = count;
    particleGeometry.setDrawRange(0, count);
    const disp = document.getElementById('particle-count-disp');
    if (disp) disp.textContent = (count / 1000).toFixed(0) + 'k';
  });
  
  document.getElementById('particle-size')?.addEventListener('input', (e) => {
    particleState.size = parseFloat(e.target.value);
    particleMaterial.uniforms.uSize.value = particleState.size;
  });
  
  document.getElementById('particle-constraint')?.addEventListener('change', (e) => {
    particleState.constraintType = e.target.value;
    // Reinitialize particles with new constraint
    for (let i = 0; i < MAX_PARTICLES; i++) {
      initializeParticlePosition(i);
    }
    particleGeometry.attributes.position.needsUpdate = true;
  });
  
  document.getElementById('particle-constraint-scale')?.addEventListener('input', (e) => {
    particleState.constraintScale = parseFloat(e.target.value);
    // Reinitialize particles with new scale
    for (let i = 0; i < MAX_PARTICLES; i++) {
      initializeParticlePosition(i);
    }
    particleGeometry.attributes.position.needsUpdate = true;
  });
  
  document.getElementById('particle-color1')?.addEventListener('input', (e) => {
    particleState.primaryColor = new THREE.Color(e.target.value);
    particleMaterial.uniforms.uPrimaryColor.value = particleState.primaryColor;
  });
  
  document.getElementById('particle-color2')?.addEventListener('input', (e) => {
    particleState.secondaryColor = new THREE.Color(e.target.value);
    particleMaterial.uniforms.uSecondaryColor.value = particleState.secondaryColor;
  });
  
  document.getElementById('particle-focal')?.addEventListener('input', (e) => {
    particleState.focalLength = parseFloat(e.target.value);
    particleMaterial.uniforms.uFocalLength.value = particleState.focalLength;
  });
  
  document.getElementById('particle-aperture')?.addEventListener('input', (e) => {
    particleState.aperture = parseFloat(e.target.value);
    particleMaterial.uniforms.uAperture.value = particleState.aperture;
  });
  
  document.getElementById('particle-focus')?.addEventListener('input', (e) => {
    particleState.focusDistance = parseFloat(e.target.value);
    particleMaterial.uniforms.uFocusDistance.value = particleState.focusDistance;
  });
  
  document.getElementById('particle-bloom')?.addEventListener('input', (e) => {
    particleState.bloomIntensity = parseFloat(e.target.value);
    particleMaterial.uniforms.uBloomIntensity.value = particleState.bloomIntensity;
  });
  
  // ===== BACKGROUND LAYER RENDERING =====
  const bgCanvas = document.getElementById('bg-layer');
  const bgCtx = bgCanvas?.getContext('2d');

  function resizeBgCanvas() {
    const cont = document.getElementById('poster-container');
    if (!bgCanvas || !cont) return;
    bgCanvas.width = cont.clientWidth || 1;
    bgCanvas.height = cont.clientHeight || 1;
  }

  function renderBackground() {
    if (!bgCanvas || !bgCtx) return;
    
    const bgTypeEl = document.getElementById('bg-type');
    const color1El = document.getElementById('bg-color1');
    const color2El = document.getElementById('bg-color2');
    const angleEl = document.getElementById('bg-angle');
    
    const bgType = bgTypeEl?.value || 'solid';
    const color1 = color1El?.value || '#1a1a2e';
    const color2 = color2El?.value || '#16213e';
    const angle = parseFloat(angleEl?.value) || 135;
    
    const w = bgCanvas.width || 1;
    const h = bgCanvas.height || 1;
    
    // Show/hide relevant controls
    const showGradient = bgType === 'gradient';
    const showSolid = bgType === 'solid' || bgType === 'gradient';
    const colorRow = document.getElementById('bg-color-row');
    const color2Row = document.getElementById('bg-color2-row');
    const angleRow = document.getElementById('bg-angle-row');
    
    if (colorRow) colorRow.style.display = showSolid ? 'flex' : 'none';
    if (color2Row) color2Row.style.display = showGradient ? 'flex' : 'none';
    if (angleRow) angleRow.style.display = showGradient ? 'flex' : 'none';
    
    // Clear
    bgCtx.clearRect(0, 0, w, h);
    
    if (bgType === '3d') {
      // Use 3D scene background - opaque rendering
      bgCanvas.style.display = 'none';
      scene.background = new THREE.Color(0x0a0a0f);
      renderer.setClearColor(0x0a0a0f, 1);
      renderer.autoClear = true;
      geoCanvas.style.background = 'transparent';
      return;
    }
    
    // For custom backgrounds, make 3D scene transparent
    scene.background = null;
    renderer.setClearColor(0x000000, 0);
    renderer.autoClear = false;
    bgCanvas.style.display = 'block';
    geoCanvas.style.background = 'transparent';
    
    if (bgType === 'solid') {
      bgCtx.fillStyle = color1;
      bgCtx.fillRect(0, 0, w, h);
    }
    else if (bgType === 'gradient') {
      // Calculate gradient coordinates from angle
      const rad = (angle - 90) * Math.PI / 180;
      const cx = w / 2;
      const cy = h / 2;
      const len = Math.sqrt(w * w + h * h) / 2;
      
      const x1 = cx - Math.cos(rad) * len;
      const y1 = cy - Math.sin(rad) * len;
      const x2 = cx + Math.cos(rad) * len;
      const y2 = cy + Math.sin(rad) * len;
      
      const grad = bgCtx.createLinearGradient(x1, y1, x2, y2);
      grad.addColorStop(0, color1);
      grad.addColorStop(1, color2);
      bgCtx.fillStyle = grad;
      bgCtx.fillRect(0, 0, w, h);
    }
    else if (bgType === 'noise') {
      // Generate noise pattern
      const imageData = bgCtx.createImageData(w, h);
      const data = imageData.data;
      
      // Parse color1 for base color
      const r = parseInt(color1.slice(1, 3), 16);
      const g = parseInt(color1.slice(3, 5), 16);
      const b = parseInt(color1.slice(5, 7), 16);
      
      for (let i = 0; i < data.length; i += 4) {
        const noise = (Math.random() - 0.5) * 50;
        data[i] = Math.max(0, Math.min(255, r + noise));
        data[i + 1] = Math.max(0, Math.min(255, g + noise));
        data[i + 2] = Math.max(0, Math.min(255, b + noise));
        data[i + 3] = 255;
      }
      
      bgCtx.putImageData(imageData, 0, 0);
    }
  }

  // Background control handlers
  document.getElementById('bg-type')?.addEventListener('change', renderBackground);
  document.getElementById('bg-color1')?.addEventListener('input', renderBackground);
  document.getElementById('bg-color2')?.addEventListener('input', renderBackground);
  document.getElementById('bg-angle')?.addEventListener('input', renderBackground);

  // Initial background setup
  resizeBgCanvas();
  renderBackground();
  
  // Initialize sensor physics
  setTimeout(initSensorPhysics, 100);

  // Resize handler
  function resizeGeo() {
    const cont = document.getElementById('poster-container');
    if (!cont) return;
    const w = cont.clientWidth || 1;
    const h = cont.clientHeight || 1;
    renderer.setSize(w, h, false);
    composer.setSize(w, h);
    camera.aspect = w / h;
    camera.updateProjectionMatrix();
  }

  window.addEventListener('resize', resizeGeo);
  setTimeout(resizeGeo, 100);

  // Helper functions
  function getVal(id, type = 'float') {
    const el = document.getElementById(id);
    if (!el) return type === 'bool' ? false : 0;
    if (type === 'bool') return el.checked;
    if (type === 'val') return el.value;
    return parseFloat(el.value);
  }

  // ===== SIMULATION LOOP =====
  let simT = 0;

  setInterval(() => {
    if (getVal('pause', 'bool')) return;

    const speed = getVal('speed');
    const step = speed * 0.16;
    const noise = getVal('noise');
    const attr = getVal('attractor');
    const mode = getVal('mode', 'val');
    const preset = parseInt(getVal('ncaPreset', 'val') || '0');
    const colormapVal = getVal('colormap', 'val');

    // NCA Step
    for (let i = 0; i < 2; i++) {
      gl.bindFramebuffer(gl.FRAMEBUFFER, pong.fbo);
      gl.viewport(0, 0, W, H);
      gl.useProgram(progNCA);

      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, ping.tex);
      gl.uniform1i(gl.getUniformLocation(progNCA, 'uState'), 0);

      gl.activeTexture(gl.TEXTURE1);
      gl.bindTexture(gl.TEXTURE_2D, targetTex);
      gl.uniform1i(gl.getUniformLocation(progNCA, 'uTarget'), 1);

      gl.uniform2f(gl.getUniformLocation(progNCA, 'uTexel'), 1/W, 1/H);
      gl.uniform1f(gl.getUniformLocation(progNCA, 'uT'), simT);
      gl.uniform1f(gl.getUniformLocation(progNCA, 'uStep'), step);
      gl.uniform1i(gl.getUniformLocation(progNCA, 'uMode'), mode === 'glyph' ? 1 : 0);
      gl.uniform1f(gl.getUniformLocation(progNCA, 'uAttr'), attr);
      gl.uniform1f(gl.getUniformLocation(progNCA, 'uNoiseAmp'), noise);
      gl.uniform1i(gl.getUniformLocation(progNCA, 'uPreset'), preset);

      gl.drawArrays(gl.TRIANGLES, 0, 6);
      [ping, pong] = [pong, ping];
      simT += 0.01;
    }

    // Display
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.viewport(0, 0, 512, 512);
    gl.useProgram(progDISP);

    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, ping.tex);
    gl.uniform1i(gl.getUniformLocation(progDISP, 'uState'), 0);

    gl.activeTexture(gl.TEXTURE1);
    gl.bindTexture(gl.TEXTURE_2D, originalTex);
    gl.uniform1i(gl.getUniformLocation(progDISP, 'uOriginal'), 1);

    const cmMap = { ice: 0, fire: 1, plasma: 2, viridis: 3, magma: 4, mono: 5, original: 6 };
    gl.uniform1i(gl.getUniformLocation(progDISP, 'uColorMap'), cmMap[colormapVal] || 0);

    gl.drawArrays(gl.TRIANGLES, 0, 6);
  }, 30);

  // ===== CAMERA FUNCTIONS =====
  function updateCamera() {
    // Update FOV
    camera.fov = cameraState.fov;
    camera.updateProjectionMatrix();
    
    // Calculate camera position based on distance, height, tilt
    const tiltRad = cameraState.tilt * Math.PI / 180;
    const rollRad = cameraState.roll * Math.PI / 180;
    
    // Set orbit controls target and position
    controls.target.set(0, 0, 0);
    
    // Apply height offset
    const baseY = cameraState.height;
    
    // Get current horizontal angle from controls
    const spherical = new THREE.Spherical();
    spherical.setFromVector3(camera.position.clone().sub(controls.target));
    spherical.radius = cameraState.distance;
    
    const newPos = new THREE.Vector3();
    newPos.setFromSpherical(spherical);
    newPos.y += baseY;
    
    camera.position.copy(newPos);
    
    // Apply tilt (pitch offset)
    if (cameraState.tilt !== 0) {
      const lookDir = controls.target.clone().sub(camera.position).normalize();
      const right = new THREE.Vector3().crossVectors(lookDir, camera.up).normalize();
      const tiltAxis = right;
      const tiltQuat = new THREE.Quaternion().setFromAxisAngle(tiltAxis, tiltRad);
      camera.quaternion.premultiply(tiltQuat);
    }
    
    // Apply roll (Dutch angle)
    if (cameraState.roll !== 0) {
      camera.rotation.z = rollRad;
    } else {
      camera.rotation.z = 0;
    }
    
    controls.update();
  }

  function applyCameraPreset(presetName) {
    const preset = cameraPresets[presetName];
    if (!preset) return;
    
    Object.assign(cameraState, {
      fov: preset.fov,
      distance: preset.distance,
      height: preset.height,
      tilt: preset.tilt,
      roll: preset.roll
    });
    
    // Update UI controls
    const fovEl = document.getElementById('cam-fov');
    const distEl = document.getElementById('cam-distance');
    const heightEl = document.getElementById('cam-height');
    const tiltEl = document.getElementById('cam-tilt');
    const rollEl = document.getElementById('cam-roll');
    const fovDisp = document.getElementById('cam-fov-disp');
    
    if (fovEl) fovEl.value = preset.fov;
    if (distEl) distEl.value = preset.distance;
    if (heightEl) heightEl.value = preset.height;
    if (tiltEl) tiltEl.value = preset.tilt;
    if (rollEl) rollEl.value = preset.roll;
    if (fovDisp) fovDisp.textContent = preset.fov + '°';
    
    updateCamera();
    
    // Highlight active preset button
    document.querySelectorAll('[data-cam]').forEach(btn => {
      btn.style.borderColor = btn.dataset.cam === presetName ? 'var(--ac)' : 'transparent';
    });
  }

  // ===== RENDER LOOP =====
  let animTime = 0;

  function animate() {
    requestAnimationFrame(animate);
    animTime = performance.now() / 1000;

    // Update texture
    ncaTex.needsUpdate = true;

    // Texture transforms
    const rep = getVal('texRepeat');
    const rot = getVal('texRotate');
    const offX = getVal('texOffsetX');
    const offY = getVal('texOffsetY');
    ncaTex.repeat.set(rep, rep);
    ncaTex.offset.set(offX, offY);
    ncaTex.center.set(0.5, 0.5);
    ncaTex.rotation = rot;

    // Material properties
    mat.roughness = getVal('matRough');
    mat.metalness = getVal('matMetal');
    mat.displacementScale = getVal('disp');

    // Animation
    if (getVal('anim-rotate', 'bool')) {
      mesh.rotation.y += getVal('anim-rot-speed');
    }
    if (getVal('anim-float', 'bool')) {
      const amp = getVal('anim-float-amp');
      mesh.position.y = Math.sin(animTime * 1.5) * amp;
    }
    if (getVal('anim-pulse', 'bool')) {
      const pulse = 1 + Math.sin(animTime * 3) * 0.05;
      mesh.scale.setScalar(pulse * getVal('geoScale'));
    } else {
      mesh.scale.setScalar(getVal('geoScale'));
    }

    // Physics update (dt = ~16ms at 60fps)
    updatePhysics(0.016);
    
    // Update particles if enabled
    if (particleSystem && particleState.enabled) {
      updateParticles(0.016);
    }
    
    updateSensors(animTime);
    controls.update();
    
    // Update effects pass uniforms
    if (effectsPass && typeof effectsState !== 'undefined') {
      effectsPass.uniforms.uTime.value = animTime;
      effectsPass.uniforms.uResolution.value.set(geoCanvas.width, geoCanvas.height);
      effectsPass.uniforms.uChromaEnabled.value = effectsState.chromaEnabled;
      effectsPass.uniforms.uChromaOffset.value = effectsState.chromaOffset;
      effectsPass.uniforms.uChromaFalloff.value = effectsState.chromaFalloff;
      effectsPass.uniforms.uGlitchEnabled.value = effectsState.glitchEnabled;
      effectsPass.uniforms.uGlitchIntensity.value = effectsState.glitchIntensity;
      effectsPass.uniforms.uGlitchSpeed.value = effectsState.glitchSpeed;
      effectsPass.uniforms.uGlitchBlock.value = effectsState.glitchBlock;
      effectsPass.uniforms.uGodraysEnabled.value = effectsState.godraysEnabled;
      effectsPass.uniforms.uGodraysIntensity.value = effectsState.godraysIntensity;
      effectsPass.uniforms.uGodraysDecay.value = effectsState.godraysDecay;
      effectsPass.uniforms.uGodraysSamples.value = effectsState.godraysSamples;
      effectsPass.uniforms.uVignette.value = effectsState.vignette;
      effectsPass.uniforms.uGrain.value = effectsState.grain;
      effectsPass.uniforms.uScanlines.value = effectsState.scanlines;
    }
    
    // Manual clear for alpha support when using custom backgrounds
    const bgTypeEl = document.getElementById('bg-type');
    const bgType = bgTypeEl?.value || 'solid';
    if (bgType !== '3d') {
      renderer.clear(true, true, true);
    }
    
    composer.render();
  }

  animate();

  // Resize handler for background canvas
  window.addEventListener('resize', () => {
    resizeBgCanvas();
    renderBackground();
  });

  // ===== CONTROL HANDLERS =====
  document.getElementById('shape')?.addEventListener('change', (e) => {
    mesh.geometry.dispose();
    const factory = GEOMETRIES[e.target.value];
    if (factory) {
      mesh.geometry = factory();
    }
    rebuildSensors();
  });

  document.getElementById('mapMode')?.addEventListener('change', (e) => {
    mat.map = null;
    mat.emissiveMap = null;
    mat.displacementMap = null;
    mat.normalMap = null;
    mat.emissive.setHex(0x000000);

    const v = e.target.value;
    if (v.includes('albedo')) mat.map = ncaTex;
    if (v.includes('emissive')) {
      mat.emissiveMap = ncaTex;
      mat.emissive.setHex(0xffffff);
    }
    if (v.includes('displace')) mat.displacementMap = ncaTex;
    if (v === 'normal') {
      mat.normalMap = ncaTex;
      mat.normalScale.set(1.0, 1.0);
    }
    mat.needsUpdate = true;
  });

  document.getElementById('reset-cam')?.addEventListener('click', () => controls.reset());
  document.getElementById('reset')?.addEventListener('click', () => seedPattern(getVal('seed', 'val')));
  document.getElementById('seed')?.addEventListener('change', (e) => seedPattern(e.target.value));

  document.getElementById('bloomStrength')?.addEventListener('input', (e) => bloomPass.strength = parseFloat(e.target.value));
  document.getElementById('bloomRadius')?.addEventListener('input', (e) => bloomPass.radius = parseFloat(e.target.value));
  document.getElementById('wire')?.addEventListener('change', (e) => mat.wireframe = e.target.checked);

  // Bloom threshold
  document.getElementById('bloomThreshold')?.addEventListener('input', (e) => bloomPass.threshold = parseFloat(e.target.value));

  // ===== CAMERA HANDLERS =====
  document.getElementById('cam-fov')?.addEventListener('input', (e) => {
    cameraState.fov = parseFloat(e.target.value);
    const disp = document.getElementById('cam-fov-disp');
    if (disp) disp.textContent = cameraState.fov + '°';
    camera.fov = cameraState.fov;
    camera.updateProjectionMatrix();
  });

  document.getElementById('cam-distance')?.addEventListener('input', (e) => {
    cameraState.distance = parseFloat(e.target.value);
    // Update camera position while maintaining angle
    const dir = camera.position.clone().normalize();
    camera.position.copy(dir.multiplyScalar(cameraState.distance));
    controls.update();
  });

  document.getElementById('cam-height')?.addEventListener('input', (e) => {
    cameraState.height = parseFloat(e.target.value);
    camera.position.y = cameraState.height;
    controls.update();
  });

  document.getElementById('cam-tilt')?.addEventListener('input', (e) => {
    cameraState.tilt = parseFloat(e.target.value);
    // Tilt affects where the camera looks
    const tiltRad = cameraState.tilt * Math.PI / 180;
    controls.target.y = Math.tan(tiltRad) * cameraState.distance * 0.3;
    controls.update();
  });

  document.getElementById('cam-roll')?.addEventListener('input', (e) => {
    cameraState.roll = parseFloat(e.target.value);
    camera.rotation.z = cameraState.roll * Math.PI / 180;
  });

  // Camera preset buttons
  document.querySelectorAll('[data-cam]').forEach(btn => {
    btn.addEventListener('click', () => {
      applyCameraPreset(btn.dataset.cam);
    });
  });

  // ===== EFFECTS HANDLERS =====
  // Effects handlers
  document.getElementById('chromaEnabled')?.addEventListener('change', (e) => effectsState.chromaEnabled = e.target.checked);
  document.getElementById('chromaOffset')?.addEventListener('input', (e) => effectsState.chromaOffset = parseFloat(e.target.value));
  document.getElementById('chromaFalloff')?.addEventListener('input', (e) => effectsState.chromaFalloff = parseFloat(e.target.value));
  document.getElementById('glitchEnabled')?.addEventListener('change', (e) => effectsState.glitchEnabled = e.target.checked);
  document.getElementById('glitchIntensity')?.addEventListener('input', (e) => effectsState.glitchIntensity = parseFloat(e.target.value));
  document.getElementById('glitchSpeed')?.addEventListener('input', (e) => effectsState.glitchSpeed = parseFloat(e.target.value));
  document.getElementById('glitchBlock')?.addEventListener('input', (e) => effectsState.glitchBlock = parseInt(e.target.value));
  document.getElementById('godraysEnabled')?.addEventListener('change', (e) => effectsState.godraysEnabled = e.target.checked);
  document.getElementById('godraysIntensity')?.addEventListener('input', (e) => effectsState.godraysIntensity = parseFloat(e.target.value));
  document.getElementById('godraysDecay')?.addEventListener('input', (e) => effectsState.godraysDecay = parseFloat(e.target.value));
  document.getElementById('godraysSamples')?.addEventListener('input', (e) => effectsState.godraysSamples = parseInt(e.target.value));
  document.getElementById('scanlines')?.addEventListener('input', (e) => effectsState.scanlines = parseFloat(e.target.value));
  document.getElementById('vignette')?.addEventListener('input', (e) => effectsState.vignette = parseFloat(e.target.value));
  document.getElementById('grain')?.addEventListener('input', (e) => effectsState.grain = parseFloat(e.target.value));

  // Effect presets
  const effectPresets = {
    clean: { bloom: 0.3, chromaEnabled: false, glitchEnabled: false, godraysEnabled: false, vignette: 0.1, grain: 0, scanlines: 0 },
    cinematic: { bloom: 0.8, chromaEnabled: true, chromaOffset: 0.002, glitchEnabled: false, godraysEnabled: false, vignette: 0.5, grain: 0.08, scanlines: 0 },
    neon: { bloom: 1.8, chromaEnabled: true, chromaOffset: 0.005, glitchEnabled: false, godraysEnabled: true, godraysIntensity: 0.6, vignette: 0.3, grain: 0.02, scanlines: 0 },
    retro: { bloom: 0.4, chromaEnabled: true, chromaOffset: 0.008, glitchEnabled: false, godraysEnabled: false, vignette: 0.6, grain: 0.15, scanlines: 0.4 },
    cyber: { bloom: 1.2, chromaEnabled: true, chromaOffset: 0.006, glitchEnabled: true, glitchIntensity: 0.2, godraysEnabled: false, vignette: 0.4, grain: 0.05, scanlines: 0.2 }
  };

  document.querySelectorAll('[data-fx]').forEach(btn => {
    btn.onclick = () => {
      const preset = effectPresets[btn.dataset.fx];
      if (!preset) return;
      
      const bloomEl = document.getElementById('bloomStrength');
      const chromaEl = document.getElementById('chromaEnabled');
      const glitchEl = document.getElementById('glitchEnabled');
      const godraysEl = document.getElementById('godraysEnabled');
      const vignetteEl = document.getElementById('vignette');
      const grainEl = document.getElementById('grain');
      
      if (preset.bloom !== undefined) {
        bloomPass.strength = preset.bloom;
        if (bloomEl) bloomEl.value = preset.bloom;
      }
      Object.entries(preset).forEach(([key, val]) => {
        if (key !== 'bloom') effectsState[key] = val;
      });
      
      // Update UI checkboxes
      if (chromaEl) chromaEl.checked = preset.chromaEnabled || false;
      if (glitchEl) glitchEl.checked = preset.glitchEnabled || false;
      if (godraysEl) godraysEl.checked = preset.godraysEnabled || false;
      if (preset.vignette !== undefined && vignetteEl) vignetteEl.value = preset.vignette;
      if (preset.grain !== undefined && grainEl) grainEl.value = preset.grain;
      
      document.querySelectorAll('[data-fx]').forEach(b => b.style.borderColor = '');
      btn.style.borderColor = 'var(--accent)';
    };
  });

  // ===== LIGHTING CONTROLS =====
  // Create spotlight
  const spotlight = new THREE.SpotLight(0xffffff, 0, 15, Math.PI / 6, 0.5, 2);
  spotlight.position.set(0, 5, 0);
  spotlight.visible = false;
  scene.add(spotlight);
  scene.add(spotlight.target);

  document.getElementById('lightKey')?.addEventListener('input', (e) => keyLight.intensity = parseFloat(e.target.value));
  document.getElementById('lightFill')?.addEventListener('input', (e) => fillLight.intensity = parseFloat(e.target.value));
  document.getElementById('lightRim')?.addEventListener('input', (e) => rimLight.intensity = parseFloat(e.target.value));
  document.getElementById('lightAmbient')?.addEventListener('input', (e) => hemiLight.intensity = parseFloat(e.target.value));

  document.getElementById('spotEnabled')?.addEventListener('change', (e) => {
    spotlight.visible = e.target.checked;
    spotlight.intensity = e.target.checked ? parseFloat(document.getElementById('spotIntensity')?.value || 2) : 0;
  });
  document.getElementById('spotIntensity')?.addEventListener('input', (e) => { if (spotlight.visible) spotlight.intensity = parseFloat(e.target.value); });
  document.getElementById('spotAngle')?.addEventListener('input', (e) => spotlight.angle = parseFloat(e.target.value) * Math.PI / 180);
  document.getElementById('spotPenumbra')?.addEventListener('input', (e) => spotlight.penumbra = parseFloat(e.target.value));
  document.getElementById('spotColor')?.addEventListener('input', (e) => spotlight.color.set(e.target.value));

  const lightPresets = {
    studio: { key: 1.8, fill: 0.4, rim: 0.3, ambient: 1.0, spot: false },
    dramatic: { key: 2.5, fill: 0.1, rim: 0.8, ambient: 0.3, spot: true, spotIntensity: 3 },
    neon: { key: 0.5, fill: 1.2, rim: 1.5, ambient: 0.5, spot: false },
    rim: { key: 0.3, fill: 0.2, rim: 2.0, ambient: 0.4, spot: false },
    ambient: { key: 0.8, fill: 0.8, rim: 0.5, ambient: 1.8, spot: false }
  };

  document.querySelectorAll('[data-light]').forEach(btn => {
    btn.onclick = () => {
      const preset = lightPresets[btn.dataset.light];
      if (!preset) return;
      
      keyLight.intensity = preset.key;
      fillLight.intensity = preset.fill;
      rimLight.intensity = preset.rim;
      hemiLight.intensity = preset.ambient;
      
      const keyEl = document.getElementById('lightKey');
      const fillEl = document.getElementById('lightFill');
      const rimEl = document.getElementById('lightRim');
      const ambientEl = document.getElementById('lightAmbient');
      const spotEnabledEl = document.getElementById('spotEnabled');
      
      if (keyEl) keyEl.value = preset.key;
      if (fillEl) fillEl.value = preset.fill;
      if (rimEl) rimEl.value = preset.rim;
      if (ambientEl) ambientEl.value = preset.ambient;
      
      if (preset.spot) {
        spotlight.visible = true;
        spotlight.intensity = preset.spotIntensity || 2;
        if (spotEnabledEl) spotEnabledEl.checked = true;
      } else {
        spotlight.visible = false;
        spotlight.intensity = 0;
        if (spotEnabledEl) spotEnabledEl.checked = false;
      }
      
      document.querySelectorAll('[data-light]').forEach(b => b.style.borderColor = '');
      btn.style.borderColor = 'var(--accent)';
    };
  });

  // ===== SCENE / FLOOR CONTROLS =====
  const floorGeometry = new THREE.PlaneGeometry(20, 20, 32, 32);
  const floorMaterial = new THREE.MeshStandardMaterial({
    color: 0x1a1a2e,
    transparent: true,
    opacity: 0.5,
    roughness: 0.8,
    metalness: 0.2
  });
  const floor = new THREE.Mesh(floorGeometry, floorMaterial);
  floor.rotation.x = -Math.PI / 2;
  floor.position.y = -1.5;
  floor.visible = false;
  floor.receiveShadow = true;
  scene.add(floor);

  // Grid helper for floor
  const gridHelper = new THREE.GridHelper(20, 40, 0x444466, 0x222244);
  gridHelper.position.y = -1.49;
  gridHelper.visible = false;
  scene.add(gridHelper);

  document.getElementById('floorEnabled')?.addEventListener('change', (e) => {
    floor.visible = e.target.checked;
    const floorType = document.getElementById('floorType')?.value || 'grid';
    gridHelper.visible = e.target.checked && floorType === 'grid';
  });

  document.getElementById('floorType')?.addEventListener('change', (e) => {
    const floorEnabled = document.getElementById('floorEnabled')?.checked;
    gridHelper.visible = floorEnabled && e.target.value === 'grid';
    floorMaterial.roughness = e.target.value === 'reflect' ? 0.1 : 0.8;
    floorMaterial.metalness = e.target.value === 'reflect' ? 0.9 : 0.2;
  });

  document.getElementById('floorColor')?.addEventListener('input', (e) => floorMaterial.color.set(e.target.value));
  document.getElementById('floorOpacity')?.addEventListener('input', (e) => floorMaterial.opacity = parseFloat(e.target.value));
  document.getElementById('floorY')?.addEventListener('input', (e) => {
    floor.position.y = parseFloat(e.target.value);
    gridHelper.position.y = parseFloat(e.target.value) + 0.01;
  });

  // Background presets
  const bgPresets = {
    dark: { type: '3d', color1: '#0a0a0f', color2: '#0a0a0f' },
    midnight: { type: 'gradient', color1: '#0f0c29', color2: '#302b63', angle: 135 },
    sunset: { type: 'gradient', color1: '#ff6b35', color2: '#1a1a2e', angle: 180 },
    ocean: { type: 'gradient', color1: '#0077be', color2: '#1a1a2e', angle: 135 },
    neon: { type: 'gradient', color1: '#ff006e', color2: '#3a0ca3', angle: 45 }
  };

  document.querySelectorAll('[data-bg]').forEach(btn => {
    btn.onclick = () => {
      const preset = bgPresets[btn.dataset.bg];
      if (!preset) return;
      
      const typeEl = document.getElementById('bg-type');
      const color1El = document.getElementById('bg-color1');
      const color2El = document.getElementById('bg-color2');
      const angleEl = document.getElementById('bg-angle');
      
      if (typeEl) typeEl.value = preset.type;
      if (color1El) color1El.value = preset.color1;
      if (color2El) color2El.value = preset.color2;
      if (preset.angle && angleEl) angleEl.value = preset.angle;
      
      renderBackground();
      
      document.querySelectorAll('[data-bg]').forEach(b => b.style.borderColor = '');
      btn.style.borderColor = 'var(--accent)';
    };
  });

  // ===== COMPOSITION CONTROLS =====
  document.getElementById('comp-title-scale')?.addEventListener('input', (e) => {
    const scale = parseFloat(e.target.value);
    const title = document.querySelector('#typo-layer .title');
    if (title) title.style.transform = `scale(${scale})`;
  });

  document.getElementById('comp-spacing')?.addEventListener('input', (e) => {
    const spacing = parseFloat(e.target.value);
    const layer = document.getElementById('typo-layer');
    if (layer) layer.style.gap = `${spacing * 20}px`;
  });

  document.getElementById('comp-align')?.addEventListener('change', (e) => {
    if (e.target.value !== 'auto') {
      const layer = document.getElementById('typo-layer');
      if (layer) layer.style.textAlign = e.target.value;
    }
  });

  document.getElementById('gestalt-contrast')?.addEventListener('input', (e) => {
    const contrast = parseFloat(e.target.value);
    const layer = document.getElementById('typo-layer');
    if (layer) layer.style.filter = `contrast(${contrast})`;
  });

  // Layout presets
  const layoutPresets = {
    hero: { align: 'center', vpos: 'middle', titleScale: 1.5, spacing: 1 },
    split: { align: 'left', vpos: 'split', titleScale: 1, spacing: 1.2 },
    corner: { align: 'left', vpos: 'bottom', titleScale: 0.8, spacing: 0.8 },
    full: { align: 'center', vpos: 'middle', titleScale: 2, spacing: 1.5 },
    frame: { align: 'center', vpos: 'bottom', titleScale: 0.7, spacing: 0.6 }
  };

  document.querySelectorAll('[data-layout]').forEach(btn => {
    btn.onclick = () => {
      const preset = layoutPresets[btn.dataset.layout];
      if (!preset) return;
      
      const alignEl = document.getElementById('comp-align');
      const vposEl = document.getElementById('comp-vpos');
      const titleScaleEl = document.getElementById('comp-title-scale');
      const spacingEl = document.getElementById('comp-spacing');
      
      if (alignEl) alignEl.value = preset.align;
      if (vposEl) vposEl.value = preset.vpos;
      if (titleScaleEl) titleScaleEl.value = preset.titleScale;
      if (spacingEl) spacingEl.value = preset.spacing;
      
      // Apply
      const layer = document.getElementById('typo-layer');
      if (layer) {
        layer.style.textAlign = preset.align;
        layer.style.gap = `${preset.spacing * 20}px`;
        const title = layer.querySelector('.title');
        if (title) title.style.transform = `scale(${preset.titleScale})`;
      }
      
      document.querySelectorAll('[data-layout]').forEach(b => b.style.borderColor = '');
      btn.style.borderColor = 'var(--accent)';
    };
  });

  // ===== ENHANCED PARTICLE HANDLERS =====
  const shapeMap = { point: 0, circle: 1, ring: 2, square: 3, diamond: 4, star: 5, heart: 6, cross: 7 };
  
  document.getElementById('particle-shape')?.addEventListener('change', (e) => {
    particleState.shape = e.target.value;
    particleMaterial.uniforms.uShape.value = shapeMap[e.target.value] || 1;
  });

  document.getElementById('particle-speed')?.addEventListener('input', (e) => {
    particleState.speed = parseFloat(e.target.value);
  });

  // Extended particle presets
  const extendedParticlePresets = {
    stars: { count: 30000, size: 0.3, shape: 'star', constraint: 'sphere', scale: 6, color1: '#ffffff', color2: '#ffffd0', focal: 50, aperture: 5.6, focus: 8, bloom: 0.6 },
    firefly: { count: 3000, size: 1.0, shape: 'circle', constraint: 'box', scale: 4, color1: '#a7f432', color2: '#ffff00', focal: 50, aperture: 1.8, focus: 4, bloom: 1.5 },
    snow: { count: 10000, size: 0.5, shape: 'circle', constraint: 'box', scale: 5, color1: '#ffffff', color2: '#e0e0ff', focal: 35, aperture: 4, focus: 5, bloom: 0.3 }
  };

  // Merge with existing presets
  Object.assign(particlePresets, extendedParticlePresets);
  
  // Update preset handler to include shape
  document.querySelectorAll('[data-part]').forEach(btn => {
    btn.onclick = () => {
      const preset = particlePresets[btn.dataset.part];
      if (!preset) return;
      
      particleState.count = preset.count;
      particleState.size = preset.size;
      particleState.shape = preset.shape || 'circle';
      particleState.constraintType = preset.constraint;
      particleState.constraintScale = preset.scale;
      particleState.primaryColor = new THREE.Color(preset.color1);
      particleState.secondaryColor = new THREE.Color(preset.color2);
      particleState.focalLength = preset.focal;
      particleState.aperture = preset.aperture;
      particleState.focusDistance = preset.focus;
      particleState.bloomIntensity = preset.bloom;
      
      // Update UI with null checks
      const countEl = document.getElementById('particle-count');
      const countDispEl = document.getElementById('particle-count-disp');
      const sizeEl = document.getElementById('particle-size');
      const shapeEl = document.getElementById('particle-shape');
      const constraintEl = document.getElementById('particle-constraint');
      const scaleEl = document.getElementById('particle-constraint-scale');
      const color1El = document.getElementById('particle-color1');
      const color2El = document.getElementById('particle-color2');
      const focalEl = document.getElementById('particle-focal');
      const apertureEl = document.getElementById('particle-aperture');
      const focusEl = document.getElementById('particle-focus');
      const bloomEl = document.getElementById('particle-bloom');
      const enabledEl = document.getElementById('particles-enabled');
      
      if (countEl) countEl.value = preset.count;
      if (countDispEl) countDispEl.textContent = (preset.count / 1000).toFixed(0) + 'k';
      if (sizeEl) sizeEl.value = preset.size;
      if (shapeEl) shapeEl.value = preset.shape || 'circle';
      if (constraintEl) constraintEl.value = preset.constraint;
      if (scaleEl) scaleEl.value = preset.scale;
      if (color1El) color1El.value = preset.color1;
      if (color2El) color2El.value = preset.color2;
      if (focalEl) focalEl.value = preset.focal;
      if (apertureEl) apertureEl.value = preset.aperture;
      if (focusEl) focusEl.value = preset.focus;
      if (bloomEl) bloomEl.value = preset.bloom;
      
      // Update shader uniforms
      particleMaterial.uniforms.uSize.value = preset.size;
      particleMaterial.uniforms.uShape.value = shapeMap[preset.shape || 'circle'];
      particleMaterial.uniforms.uPrimaryColor.value = particleState.primaryColor;
      particleMaterial.uniforms.uSecondaryColor.value = particleState.secondaryColor;
      particleMaterial.uniforms.uFocalLength.value = preset.focal;
      particleMaterial.uniforms.uAperture.value = preset.aperture;
      particleMaterial.uniforms.uFocusDistance.value = preset.focus;
      particleMaterial.uniforms.uBloomIntensity.value = preset.bloom;
      
      // Update geometry
      particleGeometry.setDrawRange(0, preset.count);
      for (let i = 0; i < MAX_PARTICLES; i++) {
        initializeParticlePosition(i);
      }
      particleGeometry.attributes.position.needsUpdate = true;
      
      // Enable particles
      particleState.enabled = true;
      particleSystem.visible = true;
      if (enabledEl) enabledEl.checked = true;
      
      document.querySelectorAll('[data-part]').forEach(b => b.style.borderColor = '');
      btn.style.borderColor = 'var(--accent)';
    };
  });

  // ===== AI TEXTURE GENERATION =====
  const btnGen = document.getElementById('btnGenerate');
  const txtPrompt = document.getElementById('texturePrompt');

  if (btnGen) {
    btnGen.onclick = async () => {
      const p = txtPrompt?.value?.trim() || '';
      if (!p) return;
      if (!apiKey) {
        alert('Please add your Imagen API key in the script');
        return;
      }

      btnGen.disabled = true;
      btnGen.classList.add('loading');

    try {
      const resp = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/imagen-4.0-generate-001:predict?key=${apiKey}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          instances: [{ prompt: `${p}, seamless tileable texture, texture map, high detail, 4k` }],
          parameters: { sampleCount: 1 }
        })
      });

      const data = await resp.json();
      if (data.predictions && data.predictions[0]) {
        const img = new Image();
        img.onload = () => {
          uploadTarget(img);
          const colormapEl = document.getElementById('colormap');
          const modeEl = document.getElementById('mode');
          if (colormapEl) colormapEl.value = 'original';
          if (modeEl) modeEl.value = 'glyph';
          btnGen.disabled = false;
          btnGen.classList.remove('loading');
        };
        img.src = "data:image/png;base64," + data.predictions[0].bytesBase64Encoded;
      }
    } catch (e) {
      console.error('Texture generation error:', e);
      btnGen.disabled = false;
      btnGen.classList.remove('loading');
    }
  };
  }

  txtPrompt?.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' && btnGen) btnGen.click();
  });

  // ===== EXPORT SYSTEM =====
  document.getElementById('btn-export')?.addEventListener('click', () => {
    const btn = document.getElementById('btn-export');
    if (!btn) return;
    const originalText = btn.innerHTML;
    btn.innerHTML = '⏳ Processing...';
    btn.disabled = true;

    setTimeout(() => {
      // Determine dimensions
      const orient = state.orientation;
      let w, h;
      switch (orient) {
        case 'portrait': w = 1536; h = 2304; break;
        case 'landscape': w = 2304; h = 1536; break;
        case 'square': w = 2048; h = 2048; break;
        case 'wide': w = 2560; h = 1440; break;
        case 'ultrawide': w = 2560; h = 1097; break;
        default: w = 1536; h = 2304;
      }

      // Render at high res
      renderer.setSize(w, h, false);
      composer.setSize(w, h);
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
      composer.render();

      // Create export canvas
      const expCan = document.createElement('canvas');
      expCan.width = w;
      expCan.height = h;
      const ctx = expCan.getContext('2d');

      // Draw 3D background
      ctx.drawImage(geoCanvas, 0, 0);

      // Color grading
      const colorEl = document.getElementById('p-color');
      const profile = colorEl?.value || 'natural';
      if (profile === 'vivid') {
        ctx.globalCompositeOperation = 'overlay';
        ctx.fillStyle = 'rgba(255,255,255,0.08)';
        ctx.fillRect(0, 0, w, h);
        ctx.globalCompositeOperation = 'source-over';
      } else if (profile === 'muted') {
        ctx.fillStyle = 'rgba(128,128,128,0.1)';
        ctx.fillRect(0, 0, w, h);
      } else if (profile === 'print') {
        ctx.fillStyle = 'rgba(255,248,235,0.05)';
        ctx.fillRect(0, 0, w, h);
      } else if (profile === 'bw') {
        ctx.filter = 'grayscale(100%) contrast(1.15)';
        ctx.drawImage(expCan, 0, 0);
        ctx.filter = 'none';
      } else if (profile === 'sepia') {
        ctx.filter = 'sepia(30%) contrast(1.05)';
        ctx.drawImage(expCan, 0, 0);
        ctx.filter = 'none';
      }

      // Vignette
      const vignette = getVal('vignette');
      if (vignette > 0) {
        const gradient = ctx.createRadialGradient(w/2, h/2, 0, w/2, h/2, Math.max(w, h) * 0.7);
        gradient.addColorStop(0, 'rgba(0,0,0,0)');
        gradient.addColorStop(1, `rgba(0,0,0,${vignette})`);
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, w, h);
      }

      // Film grain
      const grain = getVal('grain');
      if (grain > 0) {
        const imageData = ctx.getImageData(0, 0, w, h);
        const data = imageData.data;
        for (let i = 0; i < data.length; i += 4) {
          const noise = (Math.random() - 0.5) * grain * 255;
          data[i] = Math.min(255, Math.max(0, data[i] + noise));
          data[i+1] = Math.min(255, Math.max(0, data[i+1] + noise));
          data[i+2] = Math.min(255, Math.max(0, data[i+2] + noise));
        }
        ctx.putImageData(imageData, 0, 0);
      }

      // Draw typography (simplified - uses CSS for positioning in preview)
      ctx.fillStyle = 'white';
      ctx.textBaseline = 'top';
      const pad = w * 0.05;
      const scale = w / 1536; // Scale factor

      // Style-specific rendering
      const style = state.style;
      
      if (style === 'swiss') {
        ctx.font = `900 ${w * 0.12}px Epilogue, sans-serif`;
        ctx.fillText(state.title.toUpperCase(), pad, pad);
        
        ctx.font = `400 ${w * 0.016}px Epilogue, sans-serif`;
        ctx.globalAlpha = 0.8;
        ctx.fillText(state.meta.toUpperCase(), pad, pad + w * 0.14);
        
        ctx.font = `400 ${w * 0.014}px Epilogue, sans-serif`;
        ctx.globalAlpha = 0.7;
        ctx.textAlign = 'left';
        const descLines = wrapText(ctx, state.desc, w * 0.4);
        descLines.forEach((line, i) => {
          ctx.fillText(line, w - pad - w * 0.42, h - pad - 100 + i * 18 * scale);
        });
        
        ctx.globalAlpha = 0.6;
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(pad, h - pad - 30);
        ctx.lineTo(w - pad, h - pad - 30);
        ctx.stroke();
        
        ctx.font = `400 ${w * 0.012}px Epilogue, sans-serif`;
        ctx.textAlign = 'left';
        ctx.fillText(`${state.sig} :: ID ${Math.abs((state.title + state.meta).split('').reduce((a, b) => ((a << 5) - a) + b.charCodeAt(0), 0)).toString(16).toUpperCase().slice(0, 6)}`, pad, h - pad - 10);
        ctx.globalAlpha = 1;
      }
      else if (style === 'brutal') {
        ctx.save();
        ctx.translate(w/2, h/2);
        ctx.rotate(-3 * Math.PI / 180);
        ctx.font = `400 ${w * 0.14}px "Archivo Black", sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 2;
        ctx.strokeText(state.title, 0, 0);
        ctx.restore();
        
        // Meta tag
        ctx.save();
        ctx.translate(pad + 30, pad + 30);
        ctx.rotate(-8 * Math.PI / 180);
        ctx.fillStyle = 'white';
        ctx.fillRect(0, 0, 280 * scale, 36 * scale);
        ctx.fillStyle = 'black';
        ctx.font = `700 ${w * 0.012}px "IBM Plex Mono", monospace`;
        ctx.textAlign = 'left';
        ctx.textBaseline = 'top';
        ctx.fillText(state.meta, 10 * scale, 8 * scale);
        ctx.restore();
        
        // Sig
        ctx.fillStyle = 'white';
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 2;
        ctx.strokeRect(w - pad - 180 * scale, pad, 180 * scale, 40 * scale);
        ctx.font = `700 ${w * 0.013}px "IBM Plex Mono", monospace`;
        ctx.textAlign = 'right';
        ctx.fillText(state.sig, w - pad - 15 * scale, pad + 12 * scale);
      }
      else if (style === 'minimal') {
        ctx.font = `900 ${w * 0.1}px "Darker Grotesque", sans-serif`;
        ctx.fillText(state.title, pad, h - pad - w * 0.15);
        
        ctx.font = `300 ${w * 0.016}px "Darker Grotesque", sans-serif`;
        ctx.globalAlpha = 0.5;
        ctx.fillText(state.meta, pad, h - pad - w * 0.04);
        
        ctx.font = `300 ${w * 0.01}px "Darker Grotesque", sans-serif`;
        ctx.globalAlpha = 0.3;
        ctx.fillText(state.sig, pad, h - pad - w * 0.01);
        ctx.globalAlpha = 1;
      }
      else {
        // Default fallback for other styles
        ctx.font = `900 ${w * 0.08}px sans-serif`;
        ctx.textAlign = 'center';
        ctx.fillText(state.title, w/2, h/2);
        
        ctx.font = `400 ${w * 0.015}px sans-serif`;
        ctx.fillText(state.meta, w/2, h/2 + w * 0.1);
      }

      // Download
      const link = document.createElement('a');
      link.download = `MonKnight_${state.style}_${Date.now()}.png`;
      link.href = expCan.toDataURL('image/png', 0.95);
      link.click();

      // Restore
      resizeGeo();
      btn.innerHTML = originalText;
      btn.disabled = false;
    }, 150);
  });

  // Text wrapping helper
  function wrapText(ctx, text, maxWidth) {
    const words = text.split(' ');
    const lines = [];
    let currentLine = '';
    
    words.forEach(word => {
      const testLine = currentLine + (currentLine ? ' ' : '') + word;
      if (ctx.measureText(testLine).width > maxWidth && currentLine) {
        lines.push(currentLine);
        currentLine = word;
      } else {
        currentLine = testLine;
      }
    });
    if (currentLine) lines.push(currentLine);
    return lines;
  }

  // ===== GRID SYSTEM =====
  const gridState = {
    show: false,
    columns: 12,
    rows: 8,
    gutter: 2,
    margin: 5,
    snapEnabled: true
  };

  function renderGridOverlay() {
    const overlay = document.getElementById('grid-overlay');
    if (!overlay) return;
    
    overlay.innerHTML = '';
    
    if (!gridState.show) {
      overlay.classList.remove('active');
      return;
    }
    
    overlay.classList.add('active');
    
    const poster = document.getElementById('poster');
    if (!poster) return;
    
    const w = poster.offsetWidth;
    const h = poster.offsetHeight;
    if (!w || !h) return;
    
    const marginPx = (gridState.margin / 100) * w;
    const gutterPx = (gridState.gutter / 100) * w;
    const availW = w - (2 * marginPx);
    const availH = h - (2 * marginPx);
    
    // Column width accounting for gutters
    const totalGutterW = gutterPx * (gridState.columns - 1);
    const colWidth = (availW - totalGutterW) / gridState.columns;
    
    // Row height accounting for gutters
    const totalGutterH = gutterPx * (gridState.rows - 1);
    const rowHeight = (availH - totalGutterH) / gridState.rows;
    
    // Draw margin areas
    const marginAreas = [
      { left: 0, top: 0, width: marginPx, height: h }, // Left
      { left: w - marginPx, top: 0, width: marginPx, height: h }, // Right
      { left: marginPx, top: 0, width: availW, height: marginPx }, // Top
      { left: marginPx, top: h - marginPx, width: availW, height: marginPx } // Bottom
    ];
    
    marginAreas.forEach(area => {
      const div = document.createElement('div');
      div.className = 'grid-margin';
      div.style.cssText = `left:${area.left}px; top:${area.top}px; width:${area.width}px; height:${area.height}px;`;
      overlay.appendChild(div);
    });
    
    // Draw columns
    for (let i = 0; i < gridState.columns; i++) {
      const x = marginPx + i * (colWidth + gutterPx);
      const col = document.createElement('div');
      col.className = 'grid-column';
      col.style.cssText = `left:${x}px; width:${colWidth}px;`;
      overlay.appendChild(col);
    }
    
    // Draw rows
    for (let i = 0; i < gridState.rows; i++) {
      const y = marginPx + i * (rowHeight + gutterPx);
      const row = document.createElement('div');
      row.className = 'grid-row';
      row.style.cssText = `top:${y}px; height:${rowHeight}px;`;
      overlay.appendChild(row);
    }
  }

  // Grid control handlers
  document.getElementById('grid-show')?.addEventListener('change', (e) => {
    gridState.show = e.target.checked;
    renderGridOverlay();
  });
  
  document.getElementById('grid-cols')?.addEventListener('input', (e) => {
    gridState.columns = parseInt(e.target.value);
    const disp = document.getElementById('grid-cols-disp');
    if (disp) disp.textContent = gridState.columns;
    renderGridOverlay();
  });
  
  document.getElementById('grid-rows')?.addEventListener('input', (e) => {
    gridState.rows = parseInt(e.target.value);
    const disp = document.getElementById('grid-rows-disp');
    if (disp) disp.textContent = gridState.rows;
    renderGridOverlay();
  });
  
  document.getElementById('grid-gutter')?.addEventListener('input', (e) => {
    gridState.gutter = parseFloat(e.target.value);
    renderGridOverlay();
  });
  
  document.getElementById('grid-margin')?.addEventListener('input', (e) => {
    gridState.margin = parseFloat(e.target.value);
    renderGridOverlay();
  });
  
  document.getElementById('snap-grid')?.addEventListener('change', (e) => {
    gridState.snapEnabled = e.target.checked;
  });

  // ===== COMPOSITION GUIDES =====
  const guideState = {
    show: false,
    type: 'none'
  };

  function renderCompositionGuides() {
    const guides = document.getElementById('comp-guides');
    if (!guides) return;
    
    guides.innerHTML = '';
    
    if (!guideState.show || guideState.type === 'none') {
      guides.classList.remove('active');
      return;
    }
    
    guides.classList.add('active');
    
    const poster = document.getElementById('poster');
    if (!poster) return;
    
    const w = poster.offsetWidth;
    const h = poster.offsetHeight;
    if (!w || !h) return;
    
    const createLine = (type, style) => {
      const div = document.createElement('div');
      div.className = `guide-line ${type}`;
      div.style.cssText = style;
      guides.appendChild(div);
    };
    
    const createPoint = (x, y) => {
      const div = document.createElement('div');
      div.className = 'guide-point';
      div.style.cssText = `left:${x}px; top:${y}px;`;
      guides.appendChild(div);
    };
    
    switch (guideState.type) {
      case 'thirds':
        // Rule of thirds
        createLine('horizontal', `top:${h/3}px;`);
        createLine('horizontal', `top:${2*h/3}px;`);
        createLine('vertical', `left:${w/3}px;`);
        createLine('vertical', `left:${2*w/3}px;`);
        // Power points
        createPoint(w/3, h/3);
        createPoint(2*w/3, h/3);
        createPoint(w/3, 2*h/3);
        createPoint(2*w/3, 2*h/3);
        break;
        
      case 'golden':
        // Golden ratio (φ ≈ 1.618)
        const phi = 1.618;
        const gw1 = w / phi;
        const gw2 = w - gw1;
        const gh1 = h / phi;
        const gh2 = h - gh1;
        createLine('horizontal', `top:${gh2}px;`);
        createLine('horizontal', `top:${gh1}px;`);
        createLine('vertical', `left:${gw2}px;`);
        createLine('vertical', `left:${gw1}px;`);
        createPoint(gw2, gh2);
        createPoint(gw1, gh1);
        break;
        
      case 'diagonal':
        // Diagonal guides
        const diag1 = document.createElement('div');
        diag1.className = 'guide-line diagonal';
        const angle1 = Math.atan2(h, w) * 180 / Math.PI;
        const len1 = Math.sqrt(w*w + h*h);
        diag1.style.cssText = `left:0; top:0; width:${len1}px; transform:rotate(${angle1}deg);`;
        guides.appendChild(diag1);
        
        const diag2 = document.createElement('div');
        diag2.className = 'guide-line diagonal';
        diag2.style.cssText = `left:0; top:${h}px; width:${len1}px; transform:rotate(-${angle1}deg);`;
        guides.appendChild(diag2);
        break;
        
      case 'center':
        // Center cross
        createLine('horizontal', `top:${h/2}px;`);
        createLine('vertical', `left:${w/2}px;`);
        createPoint(w/2, h/2);
        break;
        
      case 'phi':
        // Phi grid (more complex golden sections)
        const p = 1.618;
        for (let i = 1; i <= 3; i++) {
          const pos = w * (1 - 1/Math.pow(p, i));
          createLine('vertical', `left:${pos}px;`);
          createLine('vertical', `left:${w - pos}px;`);
        }
        for (let i = 1; i <= 3; i++) {
          const pos = h * (1 - 1/Math.pow(p, i));
          createLine('horizontal', `top:${pos}px;`);
          createLine('horizontal', `top:${h - pos}px;`);
        }
        break;
        
      case 'fibonacci':
        // Fibonacci spiral guides
        const fib = [1, 1, 2, 3, 5, 8, 13];
        const total = fib.reduce((a, b) => a + b, 0);
        let x = 0;
        fib.forEach((n, i) => {
          const lineW = (n / total) * w;
          createLine('vertical', `left:${x + lineW}px;`);
          x += lineW;
        });
        break;
    }
  }

  // Guide control handlers
  document.getElementById('guide-show')?.addEventListener('change', (e) => {
    guideState.show = e.target.checked;
    renderCompositionGuides();
  });
  
  document.getElementById('guide-type')?.addEventListener('change', (e) => {
    guideState.type = e.target.value;
    renderCompositionGuides();
  });

  // ===== DRAGGABLE TEXT SYSTEM =====
  const editState = {
    enabled: false,
    dragging: null,
    startX: 0,
    startY: 0,
    elemStartX: 0,
    elemStartY: 0,
    transforms: {}
  };

  function getSnapPoints() {
    if (!gridState.snapEnabled || !gridState.show) return [];
    
    const poster = document.getElementById('poster');
    if (!poster) return [];
    
    const w = poster.offsetWidth;
    const h = poster.offsetHeight;
    if (!w || !h) return [];
    
    const marginPx = (gridState.margin / 100) * w;
    const gutterPx = (gridState.gutter / 100) * w;
    const availW = w - (2 * marginPx);
    const availH = h - (2 * marginPx);
    const totalGutterW = gutterPx * (gridState.columns - 1);
    const colWidth = (availW - totalGutterW) / gridState.columns;
    const totalGutterH = gutterPx * (gridState.rows - 1);
    const rowHeight = (availH - totalGutterH) / gridState.rows;
    
    const points = { x: [], y: [] };
    
    // Add column edges
    for (let i = 0; i <= gridState.columns; i++) {
      const x = marginPx + i * (colWidth + gutterPx) - (i > 0 ? gutterPx : 0);
      points.x.push(x);
      if (i < gridState.columns) {
        points.x.push(x + colWidth);
      }
    }
    
    // Add row edges
    for (let i = 0; i <= gridState.rows; i++) {
      const y = marginPx + i * (rowHeight + gutterPx) - (i > 0 ? gutterPx : 0);
      points.y.push(y);
      if (i < gridState.rows) {
        points.y.push(y + rowHeight);
      }
    }
    
    // Add center lines
    points.x.push(w / 2);
    points.y.push(h / 2);
    
    return points;
  }

  function findNearestSnap(value, snapPoints, threshold = 10) {
    let nearest = null;
    let minDist = threshold;
    
    snapPoints.forEach(point => {
      const dist = Math.abs(value - point);
      if (dist < minDist) {
        minDist = dist;
        nearest = point;
      }
    });
    
    return nearest;
  }

  function showSnapIndicator(type, pos) {
    const indicator = document.getElementById(`snap-${type}`);
    if (!indicator) return;
    
    indicator.style.display = 'block';
    if (type === 'h') {
      indicator.style.top = `${pos}px`;
      indicator.style.left = '0';
    } else {
      indicator.style.left = `${pos}px`;
      indicator.style.top = '0';
    }
  }

  function hideSnapIndicators() {
    const snapH = document.getElementById('snap-h');
    const snapV = document.getElementById('snap-v');
    if (snapH) snapH.style.display = 'none';
    if (snapV) snapV.style.display = 'none';
  }

  function enableEditMode(enabled) {
    editState.enabled = enabled;
    const typoLayer = document.getElementById('typo-layer');
    if (typoLayer) {
      typoLayer.classList.toggle('edit-mode', enabled);
    }
    
    if (!enabled) {
      hideSnapIndicators();
    }
  }

  function handleDragStart(e) {
    if (!editState.enabled) return;
    
    const target = e.target.closest('.title, .meta, .desc, .sig');
    if (!target) return;
    
    const poster = document.getElementById('poster');
    if (!poster) return;
    
    e.preventDefault();
    editState.dragging = target;
    
    const rect = target.getBoundingClientRect();
    const posterRect = poster.getBoundingClientRect();
    
    editState.startX = e.clientX || e.touches?.[0]?.clientX;
    editState.startY = e.clientY || e.touches?.[0]?.clientY;
    
    // Get current transform or position
    const transform = editState.transforms[target.className] || { x: 0, y: 0 };
    editState.elemStartX = transform.x;
    editState.elemStartY = transform.y;
    
    target.classList.add('element-selected');
  }

  function handleDrag(e) {
    if (!editState.dragging) return;
    
    const poster = document.getElementById('poster');
    if (!poster) return;
    
    e.preventDefault();
    
    const clientX = e.clientX || e.touches?.[0]?.clientX;
    const clientY = e.clientY || e.touches?.[0]?.clientY;
    if (clientX === undefined || clientY === undefined) return;
    
    let dx = clientX - editState.startX;
    let dy = clientY - editState.startY;
    
    let newX = editState.elemStartX + dx;
    let newY = editState.elemStartY + dy;
    
    // Snap to grid
    if (gridState.snapEnabled && gridState.show) {
      const snapPoints = getSnapPoints();
      const rect = editState.dragging.getBoundingClientRect();
      const posterRect = poster.getBoundingClientRect();
      
      const elemLeft = rect.left - posterRect.left + newX - editState.elemStartX;
      const elemTop = rect.top - posterRect.top + newY - editState.elemStartY;
      const elemCenterX = elemLeft + rect.width / 2;
      const elemCenterY = elemTop + rect.height / 2;
      
      hideSnapIndicators();
      
      // Check horizontal snap (left, center, right of element)
      [elemLeft, elemCenterX, elemLeft + rect.width].forEach(x => {
        const snap = findNearestSnap(x, snapPoints.x);
        if (snap !== null) {
          const adjust = snap - x;
          newX += adjust;
          showSnapIndicator('v', snap);
        }
      });
      
      // Check vertical snap (top, center, bottom of element)
      [elemTop, elemCenterY, elemTop + rect.height].forEach(y => {
        const snap = findNearestSnap(y, snapPoints.y);
        if (snap !== null) {
          const adjust = snap - y;
          newY += adjust;
          showSnapIndicator('h', snap);
        }
      });
    }
    
    // Apply transform
    editState.dragging.style.transform = `translate(${newX}px, ${newY}px)`;
    editState.transforms[editState.dragging.className.split(' ')[0]] = { x: newX, y: newY };
  }

  function handleDragEnd() {
    if (editState.dragging) {
      editState.dragging.classList.remove('element-selected');
      editState.dragging = null;
    }
    hideSnapIndicators();
  }

  // Edit mode handler
  document.getElementById('edit-mode')?.addEventListener('change', (e) => {
    enableEditMode(e.target.checked);
  });

  // Drag event listeners
  const typoLayer = document.getElementById('typo-layer');
  if (typoLayer) {
    typoLayer.addEventListener('mousedown', handleDragStart);
    typoLayer.addEventListener('touchstart', handleDragStart, { passive: false });
  }
  document.addEventListener('mousemove', handleDrag);
  document.addEventListener('touchmove', handleDrag, { passive: false });
  document.addEventListener('mouseup', handleDragEnd);
  document.addEventListener('touchend', handleDragEnd);

  // ===== ROBUST EXPORT SYSTEM =====
  const exportState = {
    resolution: '2x',
    format: 'png',
    quality: 0.95
  };

  document.getElementById('export-res')?.addEventListener('change', (e) => {
    exportState.resolution = e.target.value;
  });
  
  document.getElementById('export-format')?.addEventListener('change', (e) => {
    exportState.format = e.target.value;
  });
  
  document.getElementById('export-quality')?.addEventListener('input', (e) => {
    exportState.quality = parseFloat(e.target.value);
  });

  async function exportPoster() {
    const statusEl = document.getElementById('export-status');
    const btn = document.getElementById('export-poster');
    if (!btn) return;
    
    btn.disabled = true;
    btn.textContent = 'Exporting...';
    if (statusEl) statusEl.textContent = 'Preparing export...';
    
    try {
      // Get dimensions based on orientation
      const orientations = {
        'portrait': { w: 1200, h: 1800 },
        'landscape': { w: 1800, h: 1200 },
        'square': { w: 1500, h: 1500 },
        'wide': { w: 1920, h: 1080 },
        'ultrawide': { w: 2520, h: 1080 }
      };
      
      const orient = document.getElementById('p-orient')?.value || 'portrait';
      const base = orientations[orient] || orientations.portrait;
      
      // Apply resolution multiplier
      const multipliers = { '1x': 1, '2x': 2, '3x': 3, '4x': 4 };
      const mult = multipliers[exportState.resolution] || 2;
      const w = base.w * mult;
      const h = base.h * mult;
      
      if (statusEl) statusEl.textContent = `Rendering at ${w}x${h}...`;
      
      // Create export canvas
      const exportCanvas = document.createElement('canvas');
      exportCanvas.width = w;
      exportCanvas.height = h;
      const ctx = exportCanvas.getContext('2d');
      
      // Step 1: Render background
      const bgType = document.getElementById('bg-type')?.value || 'solid';
      const bgColor = document.getElementById('bg-color')?.value || '#0a0a0f';
      
      if (bgType === 'solid' || bgType === '3d') {
        ctx.fillStyle = bgColor;
        ctx.fillRect(0, 0, w, h);
      } else if (bgType === 'gradient') {
        const c1 = document.getElementById('bg-grad1')?.value || '#0f0c29';
        const c2 = document.getElementById('bg-grad2')?.value || '#302b63';
        const angle = parseFloat(document.getElementById('bg-grad-angle')?.value || 135);
        
        const rad = angle * Math.PI / 180;
        const x1 = w/2 - Math.cos(rad) * w;
        const y1 = h/2 - Math.sin(rad) * h;
        const x2 = w/2 + Math.cos(rad) * w;
        const y2 = h/2 + Math.sin(rad) * h;
        
        const grad = ctx.createLinearGradient(x1, y1, x2, y2);
        grad.addColorStop(0, c1);
        grad.addColorStop(1, c2);
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, w, h);
      } else if (bgType === 'radial') {
        const c1 = document.getElementById('bg-grad1')?.value || '#1a1a2e';
        const c2 = document.getElementById('bg-grad2')?.value || '#0a0a0f';
        const grad = ctx.createRadialGradient(w/2, h/2, 0, w/2, h/2, Math.max(w, h) * 0.7);
        grad.addColorStop(0, c1);
        grad.addColorStop(1, c2);
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, w, h);
      }
      
      if (statusEl) statusEl.textContent = 'Rendering 3D scene...';
      
      // Step 2: Render 3D scene at high resolution
      const originalSize = { w: geoCanvas.width, h: geoCanvas.height };
      renderer.setSize(w, h);
      renderer.setPixelRatio(1);
      composer.setSize(w, h);
      bloomPass.setSize(w, h);
      
      // Render single frame
      const bgTypeEl = document.getElementById('bg-type');
      const bgTypeVal = bgTypeEl?.value || 'solid';
      if (bgTypeVal !== '3d') {
        renderer.setClearColor(0x000000, 0);
      }
      composer.render();
      
      // Draw 3D to export canvas
      ctx.drawImage(renderer.domElement, 0, 0, w, h);
      
      // Restore original size
      renderer.setSize(originalSize.w, originalSize.h);
      renderer.setPixelRatio(window.devicePixelRatio);
      composer.setSize(originalSize.w, originalSize.h);
      bloomPass.setSize(originalSize.w, originalSize.h);
      
      if (statusEl) statusEl.textContent = 'Rendering typography...';
      
      // Step 3: Render typography
      ctx.fillStyle = document.getElementById('p-color-text')?.value || '#ffffff';
      const style = state.style;
      const pad = w * 0.05;
      const scale = w / 1200;
      
      // Load fonts
      await document.fonts.ready;
      
      // Render based on style
      renderTypographyToCanvas(ctx, w, h, style, scale, pad);
      
      if (statusEl) statusEl.textContent = 'Finalizing...';
      
      // Step 4: Convert and download
      let dataUrl;
      let filename;
      const timestamp = Date.now();
      
      if (exportState.format === 'png') {
        dataUrl = exportCanvas.toDataURL('image/png');
        filename = `MonKnight_${style}_${w}x${h}_${timestamp}.png`;
      } else if (exportState.format === 'jpg') {
        // Fill background for JPG (no transparency)
        const jpgCanvas = document.createElement('canvas');
        jpgCanvas.width = w;
        jpgCanvas.height = h;
        const jpgCtx = jpgCanvas.getContext('2d');
        jpgCtx.fillStyle = bgColor;
        jpgCtx.fillRect(0, 0, w, h);
        jpgCtx.drawImage(exportCanvas, 0, 0);
        dataUrl = jpgCanvas.toDataURL('image/jpeg', exportState.quality);
        filename = `MonKnight_${style}_${w}x${h}_${timestamp}.jpg`;
      } else {
        dataUrl = exportCanvas.toDataURL('image/webp', exportState.quality);
        filename = `MonKnight_${style}_${w}x${h}_${timestamp}.webp`;
      }
      
      // Download
      const link = document.createElement('a');
      link.download = filename;
      link.href = dataUrl;
      link.click();
      
      if (statusEl) statusEl.textContent = `Exported: ${filename}`;
      
    } catch (err) {
      console.error('Export error:', err);
      if (statusEl) statusEl.textContent = `Error: ${err.message}`;
    } finally {
      btn.disabled = false;
      btn.textContent = 'Export Poster';
    }
  }

  function renderTypographyToCanvas(ctx, w, h, style, scale, pad) {
    ctx.textBaseline = 'top';
    
    // Common styles rendering
    if (style === 'swiss') {
      ctx.font = `900 ${w * 0.09}px Epilogue, sans-serif`;
      ctx.textAlign = 'left';
      ctx.fillText(state.title.toUpperCase(), pad, pad);
      
      ctx.font = `400 ${w * 0.014}px Epilogue, sans-serif`;
      ctx.globalAlpha = 0.8;
      ctx.fillText(state.meta, pad, pad + w * 0.1);
      
      ctx.globalAlpha = 0.7;
      ctx.font = `400 ${w * 0.013}px Epilogue, sans-serif`;
      const descLines = wrapText(ctx, state.desc, w * 0.35);
      descLines.forEach((line, i) => {
        ctx.fillText(line, w - pad - w * 0.35, h - pad - w * 0.08 + i * w * 0.018);
      });
      
      ctx.globalAlpha = 0.6;
      ctx.font = `400 ${w * 0.012}px Epilogue, sans-serif`;
      ctx.fillText(state.sig, pad, h - pad - w * 0.015);
      ctx.textAlign = 'right';
      ctx.fillText(`ID 0x${Math.abs((state.title + state.meta).split('').reduce((a, b) => ((a << 5) - a) + b.charCodeAt(0), 0)).toString(16).toUpperCase().slice(0, 6)}`, w - pad, h - pad - w * 0.015);
      ctx.globalAlpha = 1;
      
    } else if (style === 'brutal') {
      ctx.save();
      ctx.translate(w/2, h/2);
      ctx.rotate(-3 * Math.PI / 180);
      ctx.font = `400 ${w * 0.14}px "Archivo Black", sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.strokeStyle = ctx.fillStyle;
      ctx.lineWidth = 2 * scale;
      ctx.strokeText(state.title.toUpperCase(), 0, 0);
      ctx.restore();
      
      ctx.font = `700 ${w * 0.012}px "IBM Plex Mono", monospace`;
      ctx.textAlign = 'left';
      ctx.textBaseline = 'top';
      ctx.save();
      ctx.translate(pad + 30 * scale, pad + 30 * scale);
      ctx.rotate(-8 * Math.PI / 180);
      const metaW = ctx.measureText(state.meta).width + 20 * scale;
      ctx.fillStyle = ctx.fillStyle;
      ctx.fillRect(0, 0, metaW, 36 * scale);
      ctx.fillStyle = document.getElementById('bg-color')?.value || '#0a0a0f';
      ctx.fillText(state.meta, 10 * scale, 10 * scale);
      ctx.restore();
      
    } else if (style === 'minimal') {
      ctx.font = `900 ${w * 0.1}px "Darker Grotesque", sans-serif`;
      ctx.textAlign = 'left';
      ctx.fillText(state.title, pad, h - pad - w * 0.15);
      
      ctx.font = `300 ${w * 0.016}px "Darker Grotesque", sans-serif`;
      ctx.globalAlpha = 0.5;
      ctx.fillText(state.meta, pad, h - pad - w * 0.04);
      
      ctx.font = `300 ${w * 0.01}px "Darker Grotesque", sans-serif`;
      ctx.globalAlpha = 0.3;
      ctx.fillText(state.sig, pad, h - pad - w * 0.01);
      ctx.globalAlpha = 1;
      
    } else if (style === 'editorial') {
      ctx.font = `900 ${w * 0.15}px "Bodoni Moda", serif`;
      ctx.textAlign = 'center';
      ctx.fillText(state.title.toUpperCase(), w/2, h * 0.08);
      
      ctx.font = `400 ${w * 0.01}px Manrope, sans-serif`;
      ctx.globalAlpha = 0.6;
      ctx.fillText(state.meta.toUpperCase(), w/2, h - pad);
      ctx.globalAlpha = 1;
      
    } else if (style === 'tech') {
      ctx.font = `400 ${w * 0.028}px "JetBrains Mono", monospace`;
      ctx.textAlign = 'left';
      ctx.fillText(state.title.toUpperCase(), pad, pad);
      ctx.textAlign = 'right';
      ctx.fillText(state.sig, w - pad, pad);
      
      ctx.strokeStyle = ctx.fillStyle;
      ctx.globalAlpha = 0.3;
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(pad, pad + w * 0.04);
      ctx.lineTo(w - pad, pad + w * 0.04);
      ctx.stroke();
      ctx.globalAlpha = 1;
      
    } else if (style === 'deco') {
      ctx.strokeStyle = '#d4af37';
      ctx.lineWidth = 3 * scale;
      ctx.strokeRect(w * 0.05, h * 0.05, w * 0.9, h * 0.9);
      ctx.strokeRect(w * 0.06, h * 0.06, w * 0.88, h * 0.88);
      
      ctx.fillStyle = '#d4af37';
      ctx.font = `400 ${w * 0.08}px "Abril Fatface", serif`;
      ctx.textAlign = 'center';
      ctx.fillText(state.title.toUpperCase(), w/2, h/2 - w * 0.04);
      
      ctx.font = `400 ${w * 0.01}px Manrope, sans-serif`;
      ctx.globalAlpha = 0.7;
      ctx.fillText(state.meta.toUpperCase(), w/2, h/2 + w * 0.06);
      ctx.globalAlpha = 1;
      
    } else if (style === 'neuegrafik') {
      ctx.font = `700 ${w * 0.1}px "Helvetica Neue", Helvetica, Arial, sans-serif`;
      ctx.textAlign = 'left';
      ctx.fillText(state.title.toLowerCase(), pad, pad);
      
      ctx.strokeStyle = ctx.fillStyle;
      ctx.lineWidth = 4 * scale;
      ctx.beginPath();
      ctx.moveTo(pad, pad + w * 0.11);
      ctx.lineTo(w - pad, pad + w * 0.11);
      ctx.stroke();
      
      ctx.font = `400 ${w * 0.012}px "Helvetica Neue", Helvetica, Arial, sans-serif`;
      ctx.globalAlpha = 0.6;
      ctx.fillText(state.meta, pad, pad + w * 0.13);
      ctx.globalAlpha = 1;
      
    } else {
      // Default fallback
      ctx.font = `900 ${w * 0.08}px sans-serif`;
      ctx.textAlign = 'center';
      ctx.fillText(state.title, w/2, h/2 - w * 0.05);
      
      ctx.font = `400 ${w * 0.015}px sans-serif`;
      ctx.fillText(state.meta, w/2, h/2 + w * 0.05);
      
      ctx.font = `400 ${w * 0.012}px sans-serif`;
      ctx.globalAlpha = 0.6;
      ctx.fillText(state.sig, w/2, h - pad);
      ctx.globalAlpha = 1;
    }
  }

  document.getElementById('export-poster')?.addEventListener('click', exportPoster);

  // ===== MFLUX GENERATIVE UI INTEGRATION =====
  const MFLUX_CONFIG = {
    baseUrl: 'http://127.0.0.1:8080',
    timeout: 120000,
    retries: 2
  };

  const PROMPT_STYLES = {
    photorealistic: ', photorealistic, high detail, 8k, professional photography',
    abstract: ', abstract art, geometric shapes, bold colors, artistic',
    texture: ', seamless tileable texture, texture map, high detail, 4k, pbr material',
    pattern: ', repeating pattern, seamless, decorative, graphic design',
    illustration: ', digital illustration, artistic, stylized, detailed',
    cinematic: ', cinematic lighting, dramatic, film still, movie scene',
    minimal: ', minimalist, clean, simple, modern design',
    raw: ''
  };

  // Generative UI state
  const genState = {
    isGenerating: false,
    selectedStyle: 'texture',
    selectedSize: '512x512',
    selectedModel: 'flux-schnell',
    history: [],
    lastImageData: null,
    serviceOnline: false
  };

  // UI Elements
  const genElements = {
    prompt: document.getElementById('gen-prompt'),
    style: document.getElementById('gen-style'),
    size: document.getElementById('gen-size'),
    model: document.getElementById('gen-model'),
    submit: document.getElementById('gen-submit'),
    status: document.getElementById('gen-status'),
    output: document.getElementById('gen-output'),
    preview: document.getElementById('gen-preview'),
    history: document.getElementById('gen-history'),
    serviceDot: document.getElementById('gen-service-dot'),
    serviceLabel: document.getElementById('gen-service-label'),
    applyButtons: document.querySelectorAll('.gen-apply-btn')
  };

  // Check mflux service availability
  async function checkMfluxService() {
    try {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 5000);

      const response = await fetch(`${MFLUX_CONFIG.baseUrl}/health`, {
        signal: controller.signal
      });

      clearTimeout(timeoutId);
      genState.serviceOnline = response.ok;
    } catch {
      genState.serviceOnline = false;
    }

    updateServiceStatus();
  }

  function updateServiceStatus() {
    if (genElements.serviceDot) {
      genElements.serviceDot.classList.toggle('online', genState.serviceOnline);
    }
    if (genElements.serviceLabel) {
      genElements.serviceLabel.textContent = genState.serviceOnline ? 'mflux ready' : 'mflux offline';
    }
  }

  function setGenStatus(text) {
    if (genElements.status) {
      genElements.status.textContent = text;
    }
  }

  function setGenerating(isGenerating) {
    genState.isGenerating = isGenerating;
    if (genElements.submit) {
      genElements.submit.classList.toggle('loading', isGenerating);
      genElements.submit.disabled = isGenerating;
    }
    if (genElements.prompt) {
      genElements.prompt.disabled = isGenerating;
    }
  }

  function showPreview(imageData) {
    if (genElements.preview) {
      genElements.preview.src = `data:image/png;base64,${imageData}`;
    }
    if (genElements.output) {
      genElements.output.style.display = 'flex';
    }
    genState.lastImageData = imageData;
  }

  function addToHistory(entry) {
    genState.history.unshift(entry);
    if (genState.history.length > 10) genState.history.pop();
    renderHistory();
  }

  function renderHistory() {
    if (!genElements.history) return;

    genElements.history.innerHTML = genState.history.map(entry => `
      <div class="gen-history-item" data-id="${entry.id}">
        <img src="data:image/png;base64,${entry.imageData}" alt="${entry.prompt}" />
      </div>
    `).join('');

    genElements.history.querySelectorAll('.gen-history-item').forEach(item => {
      item.addEventListener('click', () => {
        const id = item.getAttribute('data-id');
        const entry = genState.history.find(h => h.id === id);
        if (entry) {
          showPreview(entry.imageData);
          if (genElements.prompt) {
            genElements.prompt.value = entry.prompt;
          }
        }
      });
    });
  }

  // Generate image via mflux
  async function handleGenerate() {
    const prompt = genElements.prompt?.value?.trim();
    if (!prompt) {
      setGenStatus('Enter a prompt');
      return;
    }

    if (!genState.serviceOnline) {
      setGenStatus('mflux service offline');
      return;
    }

    setGenerating(true);
    setGenStatus('Starting generation...');

    // Build enhanced prompt with style
    const styleSuffix = PROMPT_STYLES[genState.selectedStyle] || '';
    const enhancedPrompt = prompt + styleSuffix;

    // Parse size
    const [width, height] = genState.selectedSize.split('x').map(Number);

    const requestBody = {
      model: genState.selectedModel,
      prompt: enhancedPrompt,
      n: 1,
      size: genState.selectedSize,
      response_format: 'b64_json'
    };

    // Model-specific parameters
    if (genState.selectedModel === 'flux-dev') {
      requestBody.num_inference_steps = 50;
      requestBody.guidance_scale = 7.5;
    } else {
      requestBody.num_inference_steps = 4;
      requestBody.guidance_scale = 0;
    }

    let lastError = null;

    for (let attempt = 0; attempt <= MFLUX_CONFIG.retries; attempt++) {
      try {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), MFLUX_CONFIG.timeout);

        setGenStatus(`Generating image${attempt > 0 ? ` (retry ${attempt})` : ''}...`);

        const response = await fetch(`${MFLUX_CONFIG.baseUrl}/v1/images/generations`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(requestBody),
          signal: controller.signal
        });

        clearTimeout(timeoutId);

        if (!response.ok) {
          const errorData = await response.json().catch(() => ({}));
          throw new Error(errorData.error?.message || `Generation failed: ${response.status}`);
        }

        const data = await response.json();

        if (!data.data || data.data.length === 0) {
          throw new Error('No image data in response');
        }

        const imageData = data.data[0].b64_json;
        showPreview(imageData);

        const entry = {
          id: `gen-${Date.now()}`,
          timestamp: Date.now(),
          prompt,
          model: genState.selectedModel,
          size: genState.selectedSize,
          imageData
        };
        addToHistory(entry);

        setGenStatus('Complete!');
        setGenerating(false);
        return;

      } catch (error) {
        lastError = error;

        if (error.name === 'AbortError') {
          setGenStatus('Generation timed out');
          setGenerating(false);
          return;
        }

        if (attempt < MFLUX_CONFIG.retries) {
          setGenStatus(`Retrying (${attempt + 1}/${MFLUX_CONFIG.retries})...`);
          await new Promise(resolve => setTimeout(resolve, 1000 * (attempt + 1)));
        }
      }
    }

    setGenStatus(`Error: ${lastError?.message || 'Generation failed'}`);
    setGenerating(false);
  }

  // Apply generated image to target
  async function handleApply(target) {
    if (!genState.lastImageData) {
      setGenStatus('No image to apply');
      return;
    }

    setGenStatus(`Applying to ${target}...`);

    try {
      const img = new Image();
      img.onload = () => {
        if (target === 'background') {
          // Draw to background canvas
          if (bgCanvas && bgCtx) {
            bgCtx.clearRect(0, 0, bgCanvas.width, bgCanvas.height);
            bgCtx.drawImage(img, 0, 0, bgCanvas.width, bgCanvas.height);
            bgCanvas.style.display = 'block';

            // Set mode to bypass if not using shader effects
            const modeEl = document.getElementById('mode');
            if (modeEl) modeEl.value = 'bypass';
          }
          setGenStatus(`Applied to background`);
        } else if (target === 'texture' || target === 'displacement' || target === 'emissive') {
          // Apply to WebGL texture
          uploadTarget(img);

          // Set appropriate mode based on target
          const modeEl = document.getElementById('mode');
          const colormapEl = document.getElementById('colormap');

          if (target === 'texture') {
            if (modeEl) modeEl.value = 'glyph';
            if (colormapEl) colormapEl.value = 'original';
          } else if (target === 'displacement') {
            if (modeEl) modeEl.value = 'default';
          } else if (target === 'emissive') {
            if (modeEl) modeEl.value = 'glyph';
          }

          setGenStatus(`Applied to ${target}`);
        }

        // Highlight active button
        genElements.applyButtons.forEach(btn => {
          btn.classList.toggle('active', btn.dataset.target === target);
        });
      };
      img.onerror = () => {
        setGenStatus('Failed to load image');
      };
      img.src = `data:image/png;base64,${genState.lastImageData}`;
    } catch (error) {
      setGenStatus(`Error: ${error.message || 'Apply failed'}`);
    }
  }

  // Bind generative UI events
  if (genElements.submit) {
    genElements.submit.addEventListener('click', handleGenerate);
  }

  if (genElements.prompt) {
    genElements.prompt.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        handleGenerate();
      }
    });
  }

  if (genElements.style) {
    genElements.style.addEventListener('change', () => {
      genState.selectedStyle = genElements.style.value;
    });
  }

  if (genElements.size) {
    genElements.size.addEventListener('change', () => {
      genState.selectedSize = genElements.size.value;
    });
  }

  if (genElements.model) {
    genElements.model.addEventListener('change', () => {
      genState.selectedModel = genElements.model.value;
    });
  }

  genElements.applyButtons.forEach(btn => {
    btn.addEventListener('click', () => {
      const target = btn.dataset.target;
      handleApply(target);
    });
  });

  // Check service on load and periodically
  checkMfluxService();
  setInterval(checkMfluxService, 30000);

  // Initialize overlays
  renderGridOverlay();
  renderCompositionGuides();
  
  // Update overlays on window resize
  window.addEventListener('resize', () => {
    renderGridOverlay();
    renderCompositionGuides();
  });

  // Initialize
  updatePreview();

  </script>
</body>
</html>